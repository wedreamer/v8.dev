***

标题： “极快解析，第 1 部分：优化扫描程序”
作者： 'Toon Verwaest （[@tverwaes](https://twitter.com/tverwaes)），丑闻优化器
化身：

*   'toon-verwaest'
    发布日期： 2019-03-25 13：33：37
    标签：
*   内部
*   解析
    推文：“1110205101652787200”
    描述： “解析器性能的基石是快速扫描程序。本文解释了 V8 的 JavaScript 扫描程序最近如何以更快的速度提高 2.1×。

***

要运行 JavaScript 程序，需要处理源文本，以便 V8 能够理解它。V8 首先将源代码解析为抽象语法树 （AST），这是一组表示程序结构的对象。该AST通过Ignition编译为字节码。这些解析 + 编译阶段的性能非常重要：V8 在编译完成之前无法运行代码。在本系列博客文章中，我们将重点介绍解析，以及在 V8 中完成的工作，以交付一个极快的解析器。

实际上，我们在解析器之前的一个阶段开始这个系列。V8 的解析器使用“扫描程序”提供的“令牌”。令牌是具有单一语义含义的一个或多个字符的块：字符串，标识符，运算符，如`++`.扫描程序通过在基础字符流中组合连续字符来构造这些令牌。

扫描程序使用 Unicode 字符流。这些 Unicode 字符始终从 UTF-16 代码单元流进行解码。只支持一种编码，以避免对扫描程序和解析器进行分支或专用化各种编码，我们选择了 UTF-16，因为这是 JavaScript 字符串的编码，并且需要相对于该编码提供源位置。这[`UTF16CharacterStream`](https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=46)提供（可能是缓冲的）UTF-16 视图，用于 V8 从 Chrome 接收的基础 Latin1、UTF-8 或 UTF-16 编码，而 Chrome 又从网络接收这些编码。除了支持多种编码之外，扫描仪和字符流之间的分离还允许 V8 透明地扫描，就好像整个源都可用一样，即使到目前为止我们可能只通过网络接收了部分数据。

![](/\_img/scanner/overview.svg)

扫描仪和字符流之间的接口是一个名为[`Utf16CharacterStream::Advance()`](https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=54)返回下一个 UTF-16 代码单元，或者`-1`以标记输入的结尾。UTF-16 不能在单个代码单元中对每个 Unicode 字符进行编码。外部字符[基本多语言平面](https://en.wikipedia.org/wiki/Plane_\(Unicode\)#Basic_Multilingual_Plane)编码为两个代码单元，也称为代理项对。扫描程序使用 Unicode 字符而不是 UTF-16 代码单元进行操作，因此它将此低级流接口包装在[`Scanner::Advance()`](https://cs.chromium.org/chromium/src/v8/src/scanner.h?sq=package:chromium\&g=0\&rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=569)将 UTF-16 代码单元解码为完整 Unicode 字符的方法。当前解码的字符被缓冲并通过扫描方法拾取，例如[`Scanner::ScanString()`](https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=775).

扫描仪[选择](https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=422)基于最大 4 个字符的特定扫描程序方法或令牌，这是 JavaScript 中最长的不明确字符序列\[^1]。一旦一个方法像`ScanString`，它将使用该令牌的其余字符，为下一个扫描的令牌缓冲不属于令牌的第一个字符。在以下情况下`ScanString`它还将扫描的字符复制到编码为 Latin1 或 UTF-16 的缓冲区中，同时解码转义序列。

\[^1]：`<!--`是 HTML 注释的开头，而`<!-`扫描为“小于”、“不”、“减号”。

## 空白

标记可以通过各种类型的空格分隔，例如换行符，空格，制表符，单行注释，多行注释等。一种类型的空格后跟其他类型的空格。如果空格导致两个标记之间的换行符，则空白会增加意义：这可能会导致[自动分号插入](https://tc39.es/ecma262/#sec-automatic-semicolon-insertion).因此，在扫描下一个令牌之前，将跳过所有空格，以跟踪是否发生了换行符。大多数现实世界的生产JavaScript代码都是缩小的，所以多字符空格很幸运并不是很常见。因此，V8 独立地统一扫描每种类型的空格，就好像它们是常规标记一样。例如，如果第一个令牌字符是`/`后跟另一个`/`，V8 将其扫描为单行注释，返回`Token::WHITESPACE`.该循环只是继续扫描令牌[直到](https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d\&l=671)我们找到一个令牌，而不是`Token::WHITESPACE`.这意味着，如果下一个令牌前面没有空格，我们将立即开始扫描相关令牌，而无需显式检查空格。

然而，循环本身会增加每个扫描令牌的开销：它需要一个分支来验证我们刚刚扫描的令牌。最好仅在我们刚刚扫描的令牌可以是`Token::WHITESPACE`.否则，我们应该打破循环。我们通过将循环本身移动到单独的循环中来做到这一点。[帮助程序方法](https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d62ec0d84f2ec8bc0d56ed7b8ed28eaee53ca94e\&l=178)当我们确定令牌不是时，我们会立即返回`Token::WHITESPACE`.尽管这些类型的更改可能看起来很小，但它们会消除每个扫描令牌的开销。这对于标点符号等非常短的标记尤其有用：

![](/\_img/scanner/punctuation.svg)

## 标识符扫描

最复杂，但也是最常见的令牌是[标识符](https://tc39.es/ecma262/#prod-Identifier)token，用于 JavaScript 中的变量名称（以及其他内容）。标识符以具有属性的 Unicode 字符开头[`ID_Start`](https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9\&l=807)，后跟带有属性的字符序列（可选）[`ID_Continue`](https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9\&l=947).查找 Unicode 字符是否具有该属性`ID_Start`或`ID_Continue`是相当昂贵的。通过插入从字符到其属性的缓存映射，我们可以加快速度。

不过，大多数JavaScript源代码都是使用ASCII字符编写的。在 ASCII 范围字符中，仅`a-z`,`A-Z`,`$`和`_`是标识符开始字符。`ID_Continue`另外包括`0-9`.我们通过为 128 个 ASCII 字符中的每个字符构建一个带有标志的表来加快标识符扫描速度，该表指示该字符是否为`ID_Start`一`ID_Continue`字符等当我们查看的字符在 ASCII 范围内时，我们会在此表中查找相应的标志，并使用单个分支验证属性。字符是标识符的一部分，直到我们看到第一个没有`ID_Continue`财产。

本文中提到的所有改进加起来，标识符扫描性能存在以下差异：

![](/\_img/scanner/identifiers-1.svg)

较长的标识符扫描速度更快似乎有悖常理。这可能会让您认为增加标识符长度对性能有益。扫描较长的标识符在 MB/s 方面只是更快，因为我们在非常紧密的循环中停留的时间更长，而不会返回到解析器。但是，从应用程序性能的角度来看，您关心的是我们可以以多快的速度扫描完整令牌。下图大致显示了我们每秒扫描的相对于令牌长度的令牌数：

![](/\_img/scanner/identifiers-2.svg)

在这里，很明显，使用较短的标识符有利于应用程序的解析性能：我们能够每秒扫描更多的令牌。这意味着我们似乎以MB / s解析速度更快的站点只是具有较低的信息密度，并且实际上每秒产生的令牌更少。

## 内部化缩小的标识符

所有字符串文本和标识符都在扫描程序和分析器之间的边界上进行重复数据删除。如果分析器请求字符串或标识符的值，它将为每个可能的文本值接收唯一的字符串对象。这通常需要哈希表查找。由于 JavaScript 代码经常被缩小，因此 V8 对单个 ASCII 字符串使用简单的查找表。

## 关键字

关键字是由语言定义的标识符的特殊子集，例如：`if`,`else`和`function`.V8 的扫描程序为关键字返回的令牌与为标识符返回的令牌不同。扫描标识符后，我们需要识别标识符是否为关键字。由于 JavaScript 中的所有关键字仅包含小写字符`a-z`，我们还保留标志，指示 ASCII 字符是否可能是关键字开始和继续字符。

如果标识符可以根据标志成为关键字，我们可以通过切换标识符的第一个字符来找到关键字候选的子集。与关键字的长度相比，第一个字符更明显，因此它减少了后续分支的数量。对于每个字符，我们根据可能的关键字长度进行分支，并且仅在长度匹配时才将标识符与关键字进行比较。

更好的做法是使用一种称为[完美的散列](https://en.wikipedia.org/wiki/Perfect_hash_function).由于关键字列表是静态的，因此我们可以计算一个完美的哈希函数，对于每个标识符，该函数最多为我们提供一个候选关键字。V8 用途[gperf](https://www.gnu.org/software/gperf/)以计算此函数。这[结果](https://cs.chromium.org/chromium/src/v8/src/parsing/keywords-gen.h)根据长度和前两个标识符字符计算哈希，以查找单个候选关键字。仅当关键字的长度与输入标识符长度匹配时，我们才会将标识符与关键字进行比较。这尤其加快了标识符不是关键字的情况，因为我们需要更少的分支来弄清楚它。

![](/\_img/scanner/keywords.svg)

## 代理项对

如前所述，我们的扫描程序在 UTF-16 编码的字符流上运行，但使用 Unicode 字符。增补平面中的字符仅对标识符标记具有特殊含义。例如，如果此类字符出现在字符串中，则它们不会终止该字符串。JS支持孤独的代理项，并且也只是从源中复制。因此，最好在绝对必要之前避免组合代理项对，并让扫描程序直接在 UTF-16 代码单元上运行，而不是 Unicode 字符。当我们扫描字符串时，我们不需要查找代理项对，将它们组合在一起，然后在我们存储字符以构建文本时再次拆分它们。扫描仪只需要处理代理项对的剩余两个位置。在令牌扫描开始时，只有当我们无法将角色识别为其他任何东西时，我们才需要[合](https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9\&l=515)代理项对，用于检查结果是否为标识符开始。同样，我们需要[合](https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9\&l=1003)处理非 ASCII 字符的标识符扫描慢速路径中的代理项对。

## `AdvanceUntil`

扫描仪与`UTF16CharacterStream`使边界非常有状态。流跟踪其在缓冲区中的位置，该位置在每个消耗的代码单元之后递增。扫描程序在返回到请求该字符的扫描方法之前缓冲接收到的代码单元。该方法读取缓冲字符并根据其值继续。这提供了很好的分层，但相当慢。去年秋天，我们的实习生Florian Sattler提出了一个改进的界面，它保留了分层的好处，同时提供了对流中代码单元的更快访问。模板化函数[`AdvanceUntil`](https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9\&l=72)，专用于特定的扫描帮助程序，为流中的每个字符调用帮助程序，直到帮助程序返回 false。这实质上提供了扫描程序对基础数据的直接访问，而不会破坏抽象。它实际上简化了扫描助手功能，因为它们不需要处理`EndOfInput`.

![](/\_img/scanner/advanceuntil.svg)

`AdvanceUntil`对于加速可能需要消耗大量字符的扫描函数特别有用。我们用它来加速前面已经显示的标识符，以及字符串\[^2]和注释。

\[^2]：无法用拉丁语1编码的字符串和标识符目前更昂贵，因为我们首先尝试将它们缓冲为拉丁语1，一旦遇到无法用拉丁语1编码的字符，就将它们转换为UTF-16。

## 结论

扫描性能是解析器性能的基石。我们调整了扫描仪，使其尽可能高效。这导致了全面的改进，根据标识符长度，单令牌扫描的性能提高了大约1.4×，字符串扫描提高了1.3×，多行注释扫描提高了2.1×，标识符扫描的性能提高了1.2-1.5×具体取决于标识符长度。

然而，我们的扫描仪只能做这么多。作为开发人员，您可以通过增加程序的信息密度来进一步提高解析性能。最简单的方法是缩小源代码，去除不必要的空格，并尽可能避免使用非 ASCII 标识符。理想情况下，这些步骤作为生成过程的一部分是自动化的，在这种情况下，您在编写代码时不必担心它。
