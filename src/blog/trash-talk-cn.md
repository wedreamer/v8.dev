***

标题： '垃圾谈话：奥里诺科垃圾收集器'
作者： '彼得'嘉宝' 马歇尔 （[@hooraybuffer](https://twitter.com/hooraybuffer))'
化身：

*   “彼得-马歇尔”
    日期： 2019-01-03 17：45：34
    标签：
*   内部
*   记忆
*   介绍
    描述：“Orinoco，V8 的垃圾回收器，从一个顺序停止世界实现演变为一个具有增量回退的并行和并发收集器。
    推文：“1080867305532416000”

***

在过去的几年中，V8垃圾收集器（GC）发生了很大变化。Orinoco 项目采用了一个顺序的、停止世界的垃圾回收器，并将其转变为一个具有增量回退的并行和并发收集器。

：：：备注
**注意：**如果您更喜欢观看演示文稿而不是阅读文章，那么请欣赏下面的视频！如果没有，请跳过视频并继续阅读。
:::

<figure>
  <div class="video video-16:9">
    <iframe src="https://www.youtube.com/embed/Scxz6jVS4Ls" width="640" height="360" loading="lazy"></iframe>
  </div>
</figure>

任何垃圾回收器都有一些必须定期执行的基本任务：

1.  识别活/死物体
2.  回收/重用死物占用的内存
3.  紧凑型/碎片整理内存（可选）

这些任务可以按顺序执行，也可以任意交错执行。一种直接的方法是暂停JavaScript执行，并在主线程上按顺序执行这些任务中的每一个。这可能会导致主线程上的卡顿和延迟问题，我们已经在[以前](/blog/jank-busters) [博客文章](/blog/orinoco)，以及降低程序吞吐量。

## 主要 GC （Full Mark-Compact） { #major-gc }

主要 GC 从整个堆中收集垃圾。

![Major GC happens in three phases: marking, sweeping and compacting.](/\_img/trash-talk/01.svg)

### 标记

弄清楚哪些对象可以收集是垃圾回收的重要组成部分。垃圾回收器通过使用可访问性作为“活动性”的代理来实现此目的。这意味着必须保留运行时中当前可访问的任何对象，并且可以收集任何无法访问的对象。

标记是找到可访问对象的过程。GC 从一组已知对象指针（称为根集）开始。这包括执行堆栈和全局对象。然后，它跟随指向 JavaScript 对象的每个指针，并将该对象标记为可访问。GC 跟随该对象中的每个指针，并以递归方式继续此过程，直到找到并标记了运行时中可访问的每个对象。

### 席卷

扫描是一个过程，其中死对象留下的内存间隙被添加到称为自由列表的数据结构中。标记完成后，GC 会查找无法访问的对象留下的连续间隙，并将其添加到相应的自由列表中。自由列表由内存块的大小分隔，以便快速查找。将来，当我们想要分配内存时，我们只需查看自由列表并找到适当大小的内存块。

### 压 实

主要的 GC 还选择根据碎片启发式抽取/压缩某些页面。您可以将压缩视为旧PC上的硬盘碎片整理。我们将幸存的对象复制到当前未压缩的其他页面中（使用该页面的自由列表）。通过这种方式，我们可以利用死物体留下的记忆中微小的分散间隙。

复制幸存对象的垃圾回收器的一个潜在弱点是，当我们分配大量长寿对象时，我们支付了复制这些对象的高昂成本。这就是为什么我们选择只压缩一些高度碎片化的页面，只对其他页面执行扫描，这不会复制幸存的对象。

## 分代布局

V8 中的堆被拆分为不同的区域，称为[代](/blog/orinoco-parallel-scavenger).有年轻一代（进一步分为“托儿所”和“中级”子代）和老一代。首先将对象分配到托儿所。如果他们在下一个GC中幸存下来，他们仍然留在年轻一代，但被认为是“中间人”。如果他们在另一个GC中幸存下来，他们就会被转移到老一代。

![The V8 heap is split into generations. Objects are moved through generations when they survive a GC.](/\_img/trash-talk/02.svg)

在垃圾回收中，有一个重要的术语：“代际假说”。这基本上表明大多数物体在年轻时就死了。换句话说，从GC的角度来看，大多数对象都被分配了，然后几乎立即变得无法访问。这不仅适用于 V8 或 JavaScript，也适用于大多数动态语言。

V8 的代际堆布局旨在利用有关对象生存期的这一事实。GC 是一个压缩/移动 GC，这意味着它复制在垃圾回收中幸存下来的对象。这似乎有悖常理：在 GC 时间复制对象的成本很高。但我们知道，根据世代假设，只有很小一部分对象实际上在垃圾回收中幸存下来。通过仅移动存活的对象，所有其他分配都成为“隐式”垃圾。这意味着我们只支付与幸存对象数量成比例的成本（复制成本），而不是分配数量。

## Minor GC （Scavenger） { #minor-gc }

V8 中有两个垃圾回收器。这[**主要 GC（标记紧凑）**](#major-gc)从整个堆中收集垃圾。这**小GC（清道夫）**收集年轻一代的垃圾。主要的GC可以有效地从整个堆中收集垃圾，但代际假设告诉我们，新分配的对象很可能需要垃圾回收。

在只收集年轻一代的清道夫中，幸存的物品总是被疏散到一个新的页面。V8为年轻一代采用了“半空间”设计。这意味着总空间的一半始终是空的，以允许此疏散步骤。在拾荒期间，这个最初空旷的区域被称为“到太空”。我们从中复制的区域称为“从空间”。在最坏的情况下，每个对象都可以在清除中幸存下来，我们需要复制每个对象。

对于拾荒，我们还有一组额外的根，它们是从旧到新的参考。这些是旧空间中的指针，指的是年轻一代的物体。我们不是跟踪每个清除的整个堆图，而是使用[写入障碍](https://www.memorymanagement.org/glossary/w.html#term-write-barrier)以维护从旧到新引用的列表。当与堆栈和全局相结合时，我们知道每一个参考都进入年轻一代，而不需要追溯整个老一代。

撤离步骤将所有幸存的对象移动到连续的内存块（在页面中）。这具有完成消除碎片的优点 - 死物体留下的间隙。然后，我们围绕两个空间切换，即To-Space变为From-Space，反之亦然。GC 完成后，新的分配将发生在 From-Space 中的下一个空闲地址。

![The scavenger evacuates live objects to a fresh page.](/\_img/trash-talk/03.svg)

仅凭这一战略，我们很快就耗尽了年轻一代的空间。在第二个GC中幸存下来的物体被疏散到老一代，而不是太空。

清理的最后一步是更新引用已移动的原始对象的指针。每个复制的对象都会留下一个转发地址，用于更新原始指针以指向新位置。

![The scavenger evacuates ‘intermediate’ objects to the old generation, and ‘nursery’ objects to a fresh page.](/\_img/trash-talk/04.svg)

在拾荒过程中，我们实际上执行这三个步骤-标记，疏散和指针更新-都是交错的，而不是在不同的阶段。

## 奥里诺科河

这些算法和优化中的大多数在垃圾回收文献中都很常见，并且可以在许多垃圾回收语言中找到。但最先进的垃圾收集已经走过了漫长的道路。衡量垃圾回收所花费时间的一个重要指标是主线程在执行 GC 时暂停的时间量。对于传统的“停止世界”垃圾收集器来说，这个时间确实可以加起来，而这个花在做GC上的时间会以页面卡顿和渲染和延迟不佳的形式直接减损用户体验。

<figure>
  <img src="/_img/v8-orinoco.svg" width="256" height="256" alt="" loading="lazy">
  <figcaption>Logo for Orinoco, V8’s garbage collector</figcaption>
</figure>

Orinoco是GC项目的代号，利用最新和最伟大的并行，增量和并发技术进行垃圾回收，以释放主线程。这里有一些术语在GC上下文中具有特定的含义，值得详细定义它们。

### 平行

并行是主线程和辅助线程同时执行大致相等工作量的地方。这仍然是一种“停止世界”的方法，但现在总暂停时间除以参与的线程数（加上一些同步开销）。这是三种技术中最简单的一种。由于没有运行 JavaScript，因此 JavaScript 堆已暂停，因此每个帮助程序线程只需要确保它同步对其他帮助程序可能也想要访问的任何对象的访问。

![The main thread and helper threads work on the same task at the same time.](/\_img/trash-talk/05.svg)

### 增量

增量是主线程间歇性地执行少量工作的地方。我们不会在增量暂停中执行整个 GC，而只是 GC 所需总工时的一小部分。这更加困难，因为 JavaScript 在每个增量工作段之间执行，这意味着堆的状态已更改，这可能会使以前增量完成的工作无效。从图中可以看出，这并没有减少在主线程上花费的时间（实际上，它通常会略微增加主线程的时间），它只是随着时间的推移而分散。这仍然是解决我们原始问题之一的好技术：主线程延迟。通过允许JavaScript间歇性运行，同时继续垃圾回收任务，应用程序仍然可以响应用户输入并在动画上取得进展。

![Small chunks of the GC task are interleaved into the main thread execution.](/\_img/trash-talk/06.svg)

### 并发的

并发是指主线程不断执行 JavaScript，而帮助线程完全在后台执行 GC 工作。这是三种技术中最困难的：JavaScript堆上的任何内容都可以随时更改，从而使我们以前所做的工作无效。最重要的是，现在有读/写比赛需要担心，因为帮助线程和主线程同时读取或修改相同的对象。这里的优点是主线程完全可以自由地执行JavaScript - 尽管由于与帮助线程的一些同步而存在少量开销。

![GC tasks happen entirely in the background. The main thread is free to run JavaScript.](/\_img/trash-talk/07.svg)

## V8 中的 GC 状态 { #state }

### 清除

如今，V8 在年轻一代 GC 期间使用并行清理在辅助线程之间分配工作。每个线程都会接收许多指针，这些指针紧随其后，急切地将任何活动对象疏散到To-Space中。在尝试疏散对象时，清理任务必须通过原子读/写/比较和交换操作进行同步;另一个清理任务可能通过不同的路径找到了相同的对象，并尝试移动它。无论哪个帮助程序成功移动了对象，然后返回并更新指针。它留下了一个转发指针，以便到达该对象的其他工作线程可以在找到其他指针时更新它们。为了快速无同步地分配幸存的对象，清理任务使用线程本地分配缓冲区。

![Parallel scavenging distributes scavenging work across multiple helper threads and the main thread.](/\_img/trash-talk/08.svg)

### 主要 GC { #major-gc-state }

V8 中的主要 GC 从并发标记开始。当堆接近动态计算的限制时，将启动并发标记任务。每个帮助程序都有许多要遵循的指针，并且它们标记找到的每个对象，因为它们遵循已发现对象中的所有引用。并发标记完全在后台进行，而 JavaScript 在主线程上执行。[写入障碍](https://dl.acm.org/citation.cfm?id=2025255)用于在帮助程序同时标记时跟踪 JavaScript 创建的对象之间的新引用。

![The major GC uses concurrent marking and sweeping, and parallel compaction and pointer updating.](/\_img/trash-talk/09.svg)

当并发标记完成，或者我们达到动态分配限制时，主线程执行快速标记完成步骤。主线程暂停在此阶段开始。这表示主要 GC 的总暂停时间。主线程再次扫描根目录，以确保标记了所有活动对象，然后与许多帮助程序一起开始并行压缩和指针更新。并非所有旧空间中的页面都符合压缩条件 - 那些不符合压缩的页面将使用前面提到的自由列表进行扫描。主线程在暂停期间启动并发扫描任务。它们同时运行到并行压缩任务和主线程本身 - 即使JavaScript在主线程上运行，它们也可以继续运行。

## 空闲时间 GC

JavaScript的用户不能直接访问垃圾回收器;它完全是实现定义的。然而，V8确实为嵌入器提供了一种触发垃圾回收的机制，即使JavaScript程序本身不能。GC可以发布“空闲任务”，这是最终将被触发的可选工作。像Chrome这样的嵌入器可能有一些空闲时间或空闲时间的概念。例如，在Chrome中，以每秒60帧的速度，浏览器大约有16.6毫秒的时间来渲染动画的每一帧。如果动画工作提前完成，Chrome 可以选择在下一帧之前的空闲时间运行 GC 在空闲时间创建的一些空闲任务。

![Idle GC makes use of free time on the main thread to perform GC work proactively.](/\_img/trash-talk/10.svg)

有关更多详细信息，请参阅[我们关于空闲时间GC的深入出版物](https://queue.acm.org/detail.cfm?id=2977741).

## 要点

V8中的垃圾收集器自问世以来已经走过了漫长的道路。向现有 GC 添加并行、增量和并发技术是一项多年的努力，但已获得回报，将大量工作转移到后台任务。它大大改善了暂停时间、延迟和页面加载，使动画、滚动和用户交互更加顺畅。这[平行清道夫](/blog/orinoco-parallel-scavenger)根据工作负载，将主线程年轻一代垃圾收集总时间减少了约20%-50%。[空闲时间 GC](/blog/free-garbage-collection)当Gmail处于空闲状态时，它可以将JavaScript堆内存减少45%。[同时标记和扫描](/blog/jank-busters)将重型 WebGL 游戏中的暂停时间缩短了 50%。

但这里的工作还没有完成。减少垃圾回收暂停时间对于为用户提供最佳 Web 体验仍然很重要，我们正在研究更高级的技术。最重要的是，Blink（Chrome中的渲染器）还有一个垃圾收集器（称为Oilpan），我们正在努力改进[合作](https://dl.acm.org/citation.cfm?doid=3288538.3276521)在两个收集者之间，并将一些新技术从奥里诺科移植到油盘。

大多数开发人员在开发JavaScript程序时不需要考虑GC，但是了解一些内部可以帮助你考虑内存使用情况和有用的编程模式。例如，对于 V8 堆的生成结构，从垃圾回收器的角度来看，短期对象实际上非常便宜，因为我们只为在收集中幸存下来的对象付费。这些类型的模式适用于许多垃圾回收语言，而不仅仅是JavaScript。
