***

标题： 'Jank Busters Part Ii： Orinoco'
作者：“Jank破坏者：Ulan Degenbaev，Michael Lippautz和Hannes Payer”
化身：

*   '乌兰-德根巴耶夫'
*   “迈克尔-利普茨”
*   “hannes-payer”
    日期： 2016-04-12 13：33：37
    标签：
*   内部
*   记忆
    描述： “本文介绍了三项优化，为 V8 中代号为 Orinoco 的新垃圾回收器奠定了基础。

***

在[以前的博客文章](/blog/jank-busters)，我们介绍了垃圾回收中断流畅浏览体验引起的卡顿问题。在这篇博客文章中，我们介绍了三种优化，为V8中的新垃圾回收器奠定了基础，代号为*奥里诺科河*.Orinoco 基于这样一种理念，即在没有严格生成边界的情况下实现大部分并行和并发垃圾回收器将减少垃圾回收卡顿和内存消耗，同时提供高吞吐量。我们决定在 V8 树尖上逐步发布 Orinoco 的功能，而不是将 Orinoco 作为单独的垃圾回收器来实现标志，以便立即使用户受益。本文中讨论的三个功能是并行压缩、并行记住集处理和黑色分配。

V8 实现了[代际垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_\(computer_science\)#Generational)物体可能在年轻一代内移动，从年轻一代到老一代，并在老一代内移动。移动对象的成本很高，因为需要将对象的基础内存复制到新位置，并且指向这些对象的指针也会更新。图1显示了这些阶段以及它们在Orinoco之前是如何执行的。从本质上讲，首先移动对象，然后更新这些对象之间的指针，所有这些都按顺序排列，从而导致可观察到的卡顿。

![Figure 1: Sequential moving of objects and updating pointers](/\_img/orinoco/sequential.png)

V8 将其堆内存划分为固定大小的块（称为页面），这些块分配给年轻或旧的一代空间。对象最初是在年轻一代中分配的。在垃圾回收后，活体在年轻一代中移动一次。在另一个垃圾回收中幸存下来的对象将提升为旧一代。对于这两个阶段，我们统称为年轻一代疏散，我们并行化基于页面的记忆复制。在年轻一代中，移动对象总是涉及在新页面上分配内存（并释放旧页面），留下紧凑的内存布局。在旧一代中，这个过程以稍微不同的方式发生，因为死记忆会留下不可用的孔（或碎片）。其中一些孔可以通过免费列表重用，但其他孔被抛在后面，需要压缩才能将活动对象移动到包装得更好（可能是新的）页面。与年轻一代类似，这个过程在页面级别上是并行的。

由于年轻一代疏散和老一代压实之间没有依赖关系，Orinoco现在并行执行这些阶段，如图2所示。这些改进的结果是将压缩时间减少了75%，从平均约7ms减少到2ms以下。

![Figure 2: Parallel moving of objects and updating pointers](/\_img/orinoco/parallel.png)

Orinoco引入的第二个优化改进了垃圾回收跟踪指针的方式。当对象移动堆上的位置时，垃圾回收器必须查找包含移动对象的旧位置的所有指针，并使用新位置更新它们。由于循环访问堆以查找指针会非常慢，因此 V8 使用一种称为*记得* *设置*以跟踪堆上所有有趣的指针。如果指针指向在垃圾回收期间可能移动的对象，则该指针很有趣。例如，从旧一代到新一代的所有指针都很有趣，因为新一代对象在每个垃圾回收上移动。指向严重碎片化页面中对象的指针也很有趣，因为这些对象将在压缩过程中移动到其他页面。

以前，V8 将记住的集合实现为指针地址数组，或者*存储缓冲区*.年轻一代有一个存储缓冲区，每个碎片化的旧一代页面都有一个存储缓冲区。页面的存储缓冲区包含所有传入指针的地址，如图 3 所示。条目将追加到*写入屏障*，它保护 JavaScript 代码中的写入操作。这可能会导致重复的条目，因为存储缓冲区可能包含多次指针，并且两个不同的存储缓冲区可能包含相同的指针。重复的条目使指针更新阶段的并行化变得困难，因为两个线程尝试更新同一指针会导致数据争用。

![Figure 3: Old remembered set](/\_img/orinoco/old-remembered-set.png)

Orinoco通过重新组织记住的集合来消除这种复杂性，以简化并行化并确保线程获得不相交的指针集以进行更新。现在，每个页面不再将传入的有趣指针存储在数组中，而是将源自该页面的有趣指针的偏移量存储在位图存储桶中，如图 4 所示。每个存储桶要么是空的，要么指向固定长度的位图。位图中的位对应于页面中的指针偏移量。如果设置了一个位，则指针很有趣，并且位于记住的集中。使用这种数据结构，我们可以根据页面并行化指针更新。没有重复的条目和密集的指针表示也允许我们删除复杂的代码来处理记住的集合溢出。在我们长期运行的 Gmail 基准测试中，此更改[减少](https://drive.google.com/file/d/0BxRQ51WfVicyMk9nYUk5YVY1VjQ/view)压缩垃圾回收的最大暂停时间从 42 毫秒缩短 45%，从 42 毫秒增加到 23 毫秒。

![Figure 4: New remembered set](/\_img/orinoco/new-remembered-set.png)

Orinoco引入的第三个优化是*黑色分配*，这是对垃圾回收器标记阶段的改进。黑色分配（在 V8 5.1 中提供）是一种垃圾回收技术，其中所有对象都在旧版本中分配（例如[任期前拨款](http://research.google.com/pubs/pub43823.html)或垃圾回收器提升的对象）立即标记为黑色，以便将它们指定为“活动”。黑色分配背后的直觉是，在老一代中分配的对象很可能是长寿的。因此，最近在旧一代中分配的对象至少应该在下一代旧一代垃圾回收中幸存下来，否则它们就会被错误地提升。将新分配的对象涂黑后，垃圾回收器将不会访问它们。我们通过在黑色页面上分配黑色对象来加快黑色对象的着色速度，默认情况下所有对象都是黑色的。黑页的另一个好处是它们不必被扫描，因为分配给它们的所有对象（根据定义）都是实时的。黑色分配加快了增量标记进度，因为标记工作不会随着新分配的增加而增加。在 Octane Splay 基准测试中，黑色分配的影响清晰可见，其中吞吐量和延迟得分提高了约 30%，同时由于标记进度更快，整体垃圾回收工作减少了约 20%，因此使用的内存减少了约 20%。

我们计划很快推出更多Orinoco功能。请继续关注，我们还在修补！
