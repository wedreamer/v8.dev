***

标题： “与幽灵的一年：V8视角”
作者：“Ben L. Titzer和Jaroslav Sevcik”
化身：

*   “本-蒂策尔”
*   'jaroslav-sevcik'
    日期： 2019-04-23 14：15：22
    标签：
*   安全
    推文：“1120661732836499461”
    描述： “V8团队详细介绍了他们对Spectre的分析和缓解策略，这是2018年最大的计算机安全问题之一。

***

2018年1月3日，Google Project Zero等[披露](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html)影响执行推理执行的 CPU 的新型漏洞中的前三个，称为[幽灵](https://spectreattack.com/spectre.pdf)和[崩溃](https://meltdownattack.com/meltdown.pdf).使用[推理执行](https://en.wikipedia.org/wiki/Speculative_execution)在 CPU 的机制中，攻击者可以暂时绕过代码中的隐式和显式安全检查，以防止程序读取内存中未经授权的数据。虽然处理器推测被设计为一个微架构细节，在架构级别上是看不见的，但精心设计的程序可以在推测中读取未经授权的信息，并通过侧通道（如程序片段的执行时间）披露它。

当JavaScript可以用来发起Spectre攻击时，V8团队开始参与解决这个问题。我们组建了一个应急响应团队，并与 Google 的其他团队、我们在其他浏览器供应商的合作伙伴以及我们的硬件合作伙伴密切合作。与他们合作，我们积极从事进攻性研究（构建概念验证小工具）和防御性研究（潜在攻击的缓解措施）。

幽灵攻击由两部分组成：

1.  *将原本无法访问的数据泄漏到隐藏的 CPU 状态。*所有已知的Spectre攻击都使用推测将无法访问的数据泄漏到CPU缓存中。
2.  *提取隐藏状态*以恢复无法访问的数据。为此，攻击者需要足够精确的时钟。（令人惊讶的是，低分辨率时钟就足够了，特别是对于边缘阈值等技术。

从理论上讲，击败攻击的两个组成部分中的任何一个就足够了。由于我们不知道有任何方法可以完美地击败任何部分，因此我们设计并部署了缓解措施，大大减少了泄漏到CPU缓存中的信息量。*和*使难以恢复隐藏状态的缓解措施。

## 高精度定时器

可以在推测执行中幸存下来的微小状态变化会产生相应的微小，几乎不可能的微小时间差异 - 大约在十亿分之一秒。为了直接检测个体的这种差异，攻击者程序需要一个高精度的计时器。CPU提供这样的计时器，但Web平台不会公开它们。网络平台最精确的计时器，`performance.now()`，具有个位数微秒的分辨率，最初被认为无法用于此目的。然而，两年前，一个专门研究微架构攻击的学术研究小组发表了文章。[一篇论文](https://gruss.cc/files/fantastictimers.pdf)研究了网络平台中计时器的可用性。他们得出结论，并发可变共享内存和各种分辨率恢复技术可以允许构建更高分辨率的计时器，低至纳秒分辨率。这样的计时器足够精确，可以检测单个L1缓存命中和未命中，这通常是Spectre小工具泄漏信息的方式。

## 计时器缓解措施

为了破坏检测微小时序差异的能力，浏览器供应商采取了多管齐下的方法。在所有浏览器上，分辨率`performance.now()`被减少（在Chrome中，从5微秒减少到100），并引入了随机均匀抖动以防止分辨率恢复。经过所有供应商的协商，我们共同决定采取前所未有的步骤，立即追溯禁用`SharedArrayBuffer`跨所有浏览器的API，以防止构建可用于Spectre攻击的纳秒计时器。

## 放大

在我们的进攻性研究的早期，很明显，仅靠计时器缓解是不够的。其中一个原因是攻击者可能只是重复执行他们的小工具，因此累积时间差远大于单个缓存命中或未命中。我们能够设计出可靠的小工具，一次使用许多缓存行，直到缓存容量，产生高达600微秒的时序差异。我们后来发现了不受缓存容量限制的任意放大技术。这种放大技术依赖于多次尝试读取秘密数据。

## JIT 缓解措施

为了使用Spectre读取无法访问的数据，攻击者诱使CPU以推测方式执行代码，读取通常无法访问的数据并将其编码到缓存中。可以通过两种方式打破攻击：

1.  防止推理执行代码。
2.  防止推理执行读取无法访问的数据。

我们通过插入推荐的推测屏障指令（例如英特尔的`LFENCE`，在每个关键条件分支上，并使用[retpolines](https://support.google.com/faqs/answer/7625886)用于间接分支。不幸的是，这种严厉的缓解措施大大降低了性能（2-3×Octane基准测试的速度放缓）。相反，我们选择了方法（2），插入缓解序列，以防止由于错误推测而读取机密数据。让我们在以下代码片段中说明该技术：

```js
if (condition) {
  return a[i];
}
```

为简单起见，让我们假设条件为`0`或`1`.如果 CPU 推测性地读取`a[i]`什么时候`i`超出范围，访问通常无法访问的数据。重要的观察是，在这种情况下，推测试图阅读`a[i]`什么时候`condition`是`0`.我们的缓解措施重写此程序，使其行为与原始程序完全相同，但不会泄漏任何推测加载的数据。

我们保留了一个CPU寄存器，我们称之为毒药，以跟踪代码是否在错误预测的分支中执行。在生成的代码中，毒物寄存器在所有分支和调用中维护，因此任何被错误预测的分支都会导致毒物寄存器变为`0`.然后，我们检测所有内存访问，以便它们无条件地用毒物寄存器的当前值掩盖所有负载的结果。这不会阻止处理器预测（或错误预测）分支，但会由于错误预测的分支而破坏（可能越界）加载值的信息。检测的代码如下所示（假设`a`是一个数字数组）。

```js/0,3,4
let poison = 1;
// …
if (condition) {
  poison *= condition;
  return a[i] * poison;
}
```

附加代码对程序的正常（体系结构定义的）行为没有任何影响。它仅在推测 CPU 上运行时影响微体系结构状态。如果程序是在源代码级别检测的，则现代编译器中的高级优化可能会删除此类检测。在 V8 中，我们通过在编译的后期阶段插入缓解措施来防止编译器删除这些缓解措施。

我们还使用中毒技术来防止解释器的字节码调度循环和 JavaScript 函数调用序列中错误指定的间接分支泄漏。在解释器中，我们将毒药设置为`0`如果字节码处理程序（即解释单个字节码的机器码序列）与当前字节码不匹配。对于 JavaScript 调用，我们将目标函数作为参数传递（在寄存器中），并将 poison 设置为`0`如果传入的目标函数与当前函数不匹配，则在每个函数的开头。随着中毒缓解措施的到位，我们看到辛烷基准的减速不到20%。

WebAssembly的缓解措施更简单，因为主要的安全检查是确保内存访问在范围内。对于 32 位平台，除了正常的边界检查之外，我们还将所有内存填充到下一个 2 的幂，并无条件地屏蔽用户提供的内存索引的任何上位。64 位平台不需要这样的缓解措施，因为该实现使用虚拟内存保护进行边界检查。我们尝试将 switch/case 语句编译为二进制搜索代码，而不是使用可能易受攻击的间接分支，但这在某些工作负载上太昂贵了。间接呼叫受重试保护。

## 软件缓解是一条不可持续的道路

幸运的是，我们的进攻性研究比我们的防御性研究进展得快得多，我们很快发现，软件缓解Spectre导致的所有可能的泄漏是不可行的。这是由于各种原因造成的。首先，用于打击幽灵的工程工作与其威胁水平不成比例。在 V8 中，我们面临着许多其他更糟糕的安全威胁，包括由于常规错误而导致的直接越界读取（比 Spectre 更快、更直接）、越界写入（使用 Spectre 不可能，甚至更糟）和潜在的远程代码执行（使用 Spectre 不可能，而且更糟）。其次，我们设计和实施的日益复杂的缓解措施带来了巨大的复杂性，即技术债务，实际上可能会增加攻击面和性能开销。第三，测试和维护微架构泄漏的缓解措施甚至比设计小工具本身更棘手，因为很难确保缓解措施继续按设计工作。至少有一次，重要的缓解措施被后来的编译器优化有效地撤消了。第四，我们发现，有效缓解Spectre的某些变体，特别是变体4，在软件中根本不可行，即使我们在Apple的合作伙伴为他们的JIT编译器解决了这个问题。

## 站点隔离

我们的研究得出的结论是，原则上，不受信任的代码可以使用Spectre和侧信道读取进程的整个地址空间。软件缓解措施会降低许多潜在小工具的有效性，但效率不高，也不全面。唯一有效的缓解措施是将敏感数据移出进程的地址空间。值得庆幸的是，Chrome多年来一直在努力将网站分成不同的流程，以减少由于传统漏洞而导致的攻击面。这项投资得到了回报，我们进行了生产和部署[站点隔离](https://developers.google.com/web/updates/2018/07/site-isolation)在 2018 年 5 月之前，用于尽可能多的平台。因此，Chrome 的安全模型不再假定渲染器进程中采用语言强制保密。

Spectre是一个漫长的旅程，并突出了业界和学术界供应商之间最好的合作。到目前为止，白帽子似乎领先于黑色帽子。我们仍然知道在野外没有攻击，除了好奇的修补匠和专业研究人员开发概念验证小工具。这些漏洞的新变体继续涓涓细流，并可能持续一段时间。我们将继续跟踪这些威胁并认真对待它们。

像许多具有编程语言及其实现背景的人一样，安全语言强制执行适当的抽象边界，不允许类型良好的程序读取任意内存，这一直是我们建立心智模型的保证。令人沮丧的结论是，我们的模型是错误的 - 这种保证在今天的硬件上是不正确的。当然，我们仍然相信安全语言具有巨大的工程优势，并将继续成为未来的基础，但是......在今天的硬件上，它们会泄漏一点。

有兴趣的读者可以在[我们的白皮书](https://arxiv.org/pdf/1902.05178.pdf).
