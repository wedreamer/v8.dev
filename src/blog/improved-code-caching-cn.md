***

标题： “改进的代码缓存”
作者：“Mythri Alle，Chief Code Cacher”
日期： 2018-04-24 13：33：37
化身：

*   'mythri-alle'
    标签：
*   内部
    推文：“988728000677142528”
    描述： “从 Chrome 66 开始，V8 通过在顶级执行后生成缓存来缓存更多（字节）代码。

***

V8 用途[代码缓存](/blog/code-caching)以缓存为常用脚本生成的代码。从Chrome 66开始，我们通过在顶级执行后生成缓存来缓存更多代码。这导致初始加载期间的解析和编译时间减少 20–40%。

## 背景

V8 使用两种代码缓存来缓存生成的代码，以便以后重用。第一个是 V8 的每个实例中可用的内存中缓存。初始编译后生成的代码将存储在此缓存中，并以源字符串为键控。这可以在 V8 的同一实例中重用。另一种类型的代码缓存序列化生成的代码并将其存储在磁盘上以供将来使用。此缓存不特定于 V8 的特定实例，并且可以跨 V8 的不同实例使用。这篇博客文章重点介绍了Chrome中使用的第二种代码缓存。（其他嵌入器也使用这种代码缓存;它不仅限于Chrome。但是，这篇博客文章仅关注Chrome中的使用情况。

Chrome 会将序列化生成的代码存储到磁盘缓存中，并使用脚本资源的网址对其进行键控。加载脚本时，Chrome 会检查磁盘缓存。如果脚本已被缓存，Chrome 会将序列化数据作为编译请求的一部分传递给 V8。然后，V8 反序列化此数据，而不是解析和编译脚本。还需要进行其他检查以确保代码仍然可用（例如：版本不匹配使缓存的数据不可用）。

实际数据显示，代码缓存命中率（对于可以缓存的脚本）很高（约 86%）。尽管这些脚本的缓存命中率很高，但我们每个脚本缓存的代码量并不是很高。我们的分析表明，增加缓存的代码量将减少大约40%的解析和编译JavaScript代码所花费的时间。

## 增加缓存的代码量

在前面的方法中，代码缓存与编译脚本的请求相结合。

嵌入者可以请求 V8 序列化它在顶级编译新 JavaScript 源文件期间生成的代码。V8 在编译脚本后返回序列化代码。当 Chrome 再次请求相同的脚本时，V8 会从缓存中获取序列化代码并将其反序列化。V8 完全避免了重新编译缓存中已有的函数。这些场景如下图所示：

![](../_img/improved-code-caching/warm-hot-run-1.png)

V8 只编译在顶级编译期间预期会立即执行的函数 （IIFE），并将其他函数标记为惰性编译。这有助于通过避免编译不需要的函数来帮助缩短页面加载时间，但这意味着序列化的数据仅包含预先编译的函数的代码。

在Chrome 59之前，我们必须在任何执行开始之前生成代码缓存。V8（Full-codegen）的早期基线编译器为执行上下文生成专用代码。Full-codegen 使用代码修补来执行特定执行上下文的快速路径操作。通过删除要在其他执行上下文中使用的特定于上下文的数据，无法轻松地序列化此类代码。

跟[点火的推出](/blog/launching-ignition-and-turbofan)在Chrome 59中，不再需要此限制。点火用途[数据驱动的内联缓存](https://www.youtube.com/watch?v=u7zRSm8jzvA)以快速路径操作在当前执行上下文中。上下文相关数据存储在反馈向量中，并与生成的代码分开。这为即使在脚本执行后生成代码缓存也提供了可能性。当我们执行脚本时，会编译更多的函数（标记为延迟编译），从而允许我们缓存更多代码。

V8 公开了一个新的 API，`ScriptCompiler::CreateCodeCache`，以请求独立于编译请求的代码缓存。不推荐使用请求代码缓存和编译请求，在 V8 v6.6 及更高版本中不起作用。从版本 66 开始，Chrome 会在顶级执行后使用此 API 请求代码缓存。下图显示了请求代码缓存的新方案。代码缓存是在顶级执行后请求的，因此包含稍后在执行脚本期间编译的函数的代码。在后续运行中（在下图中显示为热运行），它避免了在顶级执行期间编译函数。

![](../_img/improved-code-caching/warm-hot-run-2.png)

## 结果

此功能的性能是使用我们的内部来衡量的[实际基准测试](https://cs.chromium.org/chromium/src/tools/perf/page_sets/v8\_top\_25.py?q=v8.top\&sq=package:chromium\&l=1).下图显示了与早期缓存方案相比，解析和编译时间的缩短情况。大多数页面上的解析和编译时间都减少了约20-40%。

![](../_img/improved-code-caching/parse.png)

![](../_img/improved-code-caching/compile.png)

来自野外的数据显示，类似的结果，在桌面和移动设备上编译JavaScript代码所花费的时间减少了20-40%。在 Android 上，这种优化还意味着顶级页面加载指标减少了 1-2%，例如网页变得交互式所需的时间。我们还监控了Chrome的内存和磁盘使用情况，没有看到任何明显的回归。
