***

标题： “懒惰反序列化”
作者： '雅各布·格鲁伯 （[@schuay](https://twitter.com/schuay))'
化身：

*   “雅各布-格鲁伯”
    日期： 2018-02-12 13：33：37
    标签：
*   内部
    描述：“在 V8 v6.4 中可用的惰性反序列化，使 V8 的每个浏览器选项卡的内存消耗平均减少了 500 KB 以上。
    推文：“962989179914383360”

***

TL;DR：最近默认在[V8 v6.4](/blog/v8-release-64)，每个浏览器选项卡平均将 V8 的内存消耗减少超过 500 KB。请继续阅读以了解更多信息！

## V8 快照简介

但首先，让我们退后一步，看看 V8 如何使用堆快照来加速创建新的隔离（大致对应于 Chrome 中的浏览器选项卡）。我的同事杨国在他的文章中很好地介绍了这一点。[自定义启动快照](/blog/custom-startup-snapshots):

> JavaScript规范包括许多内置功能，从数学函数到功能齐全的正则表达式引擎。每个新创建的 V8 上下文从一开始就具有这些功能。为此，全局对象（例如，`window`对象），并且必须在创建上下文时设置所有内置功能并将其初始化到 V8 的堆中。从头开始执行此操作需要相当长的时间。
>
> 幸运的是，V8 使用了一个快捷方式来加快速度：就像解冻冷冻的披萨做一顿快餐一样，我们将以前准备的快照直接反序列化到堆中，以获得初始化的上下文。在常规台式计算机上，这可以使创建上下文的时间从 40 毫秒减少到不到 2 毫秒。在普通的手机上，这可能意味着270毫秒和10毫秒之间的差异。

回顾一下：快照对于启动性能至关重要，它们被反序列化以创建每个隔离的 V8 堆的初始状态。因此，快照的大小决定了 V8 堆的最小大小，较大的快照直接转化为每个隔离的较高内存消耗。

快照包含完全初始化新隔离所需的一切，包括语言常量（例如`undefined`value），解释器使用的内部字节码处理程序，内置对象（例如，`String`），以及安装在内置对象上的函数（例如，`String.prototype.replace`） 及其可执行文件`Code`对象。

![Startup snapshot size in bytes from 2016-01 to 2017-09. The x-axis shows V8 revision numbers.](/\_img/lazy-deserialization/startup-snapshot-size.png)

在过去两年中，快照的大小几乎增加了两倍，从 2016 年初的大约 600 KB 增加到今天的 1500 KB 以上。这种增长的绝大部分来自序列化`Code`对象，它们的数量都有所增加（例如，随着语言规范的发展和增长，最近通过对JavaScript语言的添加）;和大小（由新的[CodeStubAssembler](/blog/csa)管道作为本机代码提供，而不是更紧凑的字节码或最小化的JS格式）。

这是个坏消息，因为我们希望尽可能降低内存消耗。

## 惰性反序列化

其中一个主要的痛点是，我们过去常常将快照的全部内容复制到每个隔离中。这样做对于内置函数来说尤其浪费，这些函数都是无条件加载的，但可能永远不会被使用。

这就是惰性反序列化的用武之地。这个概念很简单：如果我们只在调用内置函数之前反序列化它们呢？

对一些最受欢迎的网站的快速调查显示，这种方法非常有吸引力：平均而言，只有30%的内置功能被使用，一些网站只使用16%。这看起来非常有希望，因为这些网站中的大多数都是重度JS用户，因此这些数字可以被视为Web潜在内存节省的（模糊）下限。

当我们开始朝着这个方向努力时，事实证明，懒惰的反序列化与V8的架构集成得很好，只有少数，主要是非侵入性的设计更改需要启动和运行：

1.  **快照中的已知位置。**在惰性反序列化之前，序列化快照中的对象顺序无关紧要，因为我们只会一次反序列化整个堆。惰性反序列化必须能够自行反序列化任何给定的内置函数，因此必须知道它在快照中的位置。
2.  **单个对象的反序列化。**V8 的快照最初是为完全堆反序列化而设计的，并且支持单对象反序列化需要处理一些怪癖，例如非连续快照布局（一个对象的序列化数据可以穿插其他对象的数据）和所谓的反向引用（可以直接引用以前在当前运行中反序列化的对象）。
3.  **惰性反序列化机制本身。**在运行时，惰性反序列化处理程序必须能够 a） 确定要反序列化的代码对象，b） 执行实际的反序列化，以及 c） 将序列化代码对象附加到所有相关函数。

我们对前两点的解决方案是添加一个新的[专用内置区域](https://cs.chromium.org/chromium/src/v8/src/snapshot/snapshot.h?l=55\&rcl=f5b1d1d4f29b238ca2f0a13bf3a7b7067854592d)到快照，其中可能只包含序列化代码对象。序列化以明确定义的顺序进行，并且每个序列化的起始偏移量`Code`对象保存在内置快照区域内的专用部分中。不允许反向引用和穿插的对象数据。

[惰性内置反序列化](https://goo.gl/dxkYDZ)由恰如其分的名称处理[`DeserializeLazy`内置](https://cs.chromium.org/chromium/src/v8/src/builtins/x64/builtins-x64.cc?l=1355\&rcl=f5b1d1d4f29b238ca2f0a13bf3a7b7067854592d)，它在反序列化时安装在所有惰性内置函数上。在运行时调用时，它会反序列化相关`Code`对象，最后将其安装在`JSFunction`（表示函数对象）和`SharedFunctionInfo`（在从同一函数文本创建的函数之间共享）。每个内置函数最多反序列化一次。

除了内置功能外，我们还实现了[字节码处理程序的惰性反序列化](https://goo.gl/QxZBL2).字节码处理程序是包含执行 V8 中每个字节码的逻辑的代码对象[点火](/blog/ignition-interpreter)译员。与内置不同，它们都没有附加的`JSFunction`也没有`SharedFunctionInfo`.相反，它们的代码对象直接存储在[调度表](https://cs.chromium.org/chromium/src/v8/src/interpreter/interpreter.h?l=94\&rcl=f5b1d1d4f29b238ca2f0a13bf3a7b7067854592d)解释器在调度到下一个字节码处理程序时索引到哪个。惰性反序列化类似于内置：[`DeserializeLazy`](https://cs.chromium.org/chromium/src/v8/src/interpreter/interpreter-generator.cc?l=3247\&rcl=f5b1d1d4f29b238ca2f0a13bf3a7b7067854592d)处理程序通过检查字节码数组来确定要反序列化的处理程序，反序列化代码对象，最后将反序列化的处理程序存储在调度表中。同样，每个处理程序最多反序列化一次。

## 结果

我们通过在Android设备上使用Chrome 65加载前1000个最受欢迎的网站来评估内存节省，无论是否使用延迟反序列化。

![](/\_img/lazy-deserialization/memory-savings.png)

平均而言，V8 的堆大小减少了 540 KB，其中 25% 的测试站点节省了 620 KB 以上，50% 的站点节省了 540 KB 以上，75% 的站点节省了 420 KB 以上。

运行时性能（在标准JS基准测试（如Speedometer）以及各种流行网站上测量）不受惰性反序列化的影响。

## 四. 今后的步骤

惰性反序列化确保每个隔离仅加载实际使用的内置代码对象。这已经是一个巨大的胜利，但我们相信有可能更进一步，将每个隔离的（内置相关）成本降低到有效零。

我们希望在今年晚些时候为您带来这方面的最新信息。敬请期待！
