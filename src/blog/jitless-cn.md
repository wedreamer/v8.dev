***

标题： '无JIT V8'
作者： '雅各布·格鲁伯 （[@schuay](https://twitter.com/schuay))'
化身：

*   “雅各布-格鲁伯”
    发布日期： 2019-03-13 13：03：19
    标签：
*   内部
    描述： 'V8 v7.4 支持 JavaScript 执行，无需在运行时分配可执行内存。
    推文：“1105777150051999744”

***

V8 v7.4 现在支持 JavaScript 执行，而无需在运行时分配可执行内存。

在其默认配置中，V8 在很大程度上依赖于在运行时分配和修改可执行内存的能力。例如，[涡轮风扇优化编译器](/blog/turbofan-jit)为热 JavaScript （JS） 函数创建实时本机代码，并且大多数 JS 正则表达式由[irregexp engine](https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html).在运行时创建可执行内存是使 V8 快速运行的一部分。

但在某些情况下，在不分配可执行内存的情况下运行 V8 可能是可取的：

1.  一些平台（例如iOS，智能电视，游戏机）禁止非特权应用程序对可执行内存进行写入访问，因此到目前为止，在那里使用V8是不可能的;和
2.  禁止写入可执行内存可减少应用程序的攻击面以进行攻击。

V8 新的无 JIT 模式旨在解决这些问题。当 V8 启动时`--jitless`标记，V8 在运行时不分配任何可执行内存的情况下运行。

它是如何工作的？从本质上讲，V8基于我们现有的技术切换到仅解释器模式：所有JS用户代码都通过[点火解释器](/blog/ignition-interpreter)，并且正则表达式模式匹配同样被解释。WebAssembly目前不受支持，但解释也处于可能性的领域。V8 的内置内容仍然被编译为原生代码，但不再是托管 JS 堆的一部分，这要归功于我们最近所做的努力[将它们嵌入到 V8 二进制文件中](/blog/embedded-builtins).

最终，这些更改允许我们创建 V8 的堆，而无需对其任何内存区域具有可执行权限。

## 结果

由于无 JIT 模式会禁用优化编译器，因此会降低性能。我们查看了各种基准测试，以更好地了解 V8 的性能特征是如何变化的。[车速表 2.0](/blog/speedometer-2)旨在表示典型的 Web 应用程序;这[网络工具基准测试](/blog/web-tooling-benchmark)包括一组常见的JS开发人员工具;我们还包括一个模拟[在客厅YouTube应用程序上浏览工作流程](https://chromeperf.appspot.com/report?sid=518c637ffa0961f965afe51d06979375467b12b87e72061598763e5a36876306).所有测量都是在 x64 Linux 桌面上进行本地进行的，运行了 5 次。

![JIT-less vs. default V8. Scores are normalized to 100 for V8’s default configuration.](/\_img/jitless/benchmarks.svg)

在无JIT模式下，车速表2.0慢约40%。大约一半的回归可以归因于禁用的优化编译器。另一半是由正则表达式解释器引起的，它最初是作为调试辅助工具的，将来会看到性能的提高。

Web 工具基准测试倾向于在 TurboFan 优化代码中花费更多时间，因此在启用无 JIT 模式时，显示 80% 的更大回归。

最后，我们在客厅YouTube应用程序上测量了一个模拟浏览会话，其中包括视频播放和菜单导航。在这里，无JIT模式大致相当，与标准V8配置相比，JS执行速度仅减慢了6%。此基准测试演示了峰值优化代码性能并不总是与[实际性能](/blog/real-world-performance)，并且在许多情况下，即使在无 JIT 模式下，嵌入器也可以保持合理的性能。

内存消耗仅略有变化，用于加载一组具有代表性的网站的 V8 堆大小中位数减少了 1.7%。

我们鼓励受限平台或具有特殊安全要求的嵌入器考虑 V8 新的无 JIT 模式，该模式现已在 V8 v7.4 中提供。一如既往，欢迎在[v8-用户](https://groups.google.com/forum/#!forum/v8-users)讨论组。

## 常见问题

*两者之间有什么区别`--jitless`和`--no-opt`?*

`--no-opt`禁用 TurboFan 优化编译器。`--jitless`禁用可执行内存的所有运行时分配。
