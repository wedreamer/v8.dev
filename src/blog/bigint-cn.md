***

标题： “将 BigInt 添加到 V8”
作者：“Jakob Kummerow，精确度的仲裁者”
发布日期：2018-05-02 13：33：37
标签：

*   ECMAScript
    描述： 'V8 现在支持 BigInts，这是一种 JavaScript 语言特性，支持任意精度的整数。
    推文：“991705626391732224”

***

在过去的几个月里，我们已经实施了对[大金](/features/bigint)在 V8 中，当前由[本提案](https://github.com/tc39/proposal-bigint)，将包含在 ECMAScript 的未来版本中。以下帖子讲述了我们的冒险故事。

## TL;DR

作为一名 JavaScript 程序员，您现在\[^1]在工具箱中拥有任意精度\[^2]的整数：

```js
const a = 2172141653n;
const b = 15346349309n;
a * b;
// → 33334444555566667777n     // Yay!
Number(a) * Number(b);
// → 33334444555566670000      // Boo!
const such_many = 2n ** 222n;
// → 6739986666787659948666753771754907668409286105635143120275902562304n
```

有关新功能以及如何使用它的详细信息，请参阅[我们关于BigInt的深入文章](/features/bigint).我们期待看到您将用它们构建的令人敬畏的东西！

\[^1]：*现在*如果您运行的是 Chrome Beta 版、Dev 版或 Canary 版，或者[预览节点.js版本](https://github.com/v8/node/tree/vee-eight-lkgr)否则*很快*（Chrome 67，Node.js树的尖端，可能大约在同一时间）。

\[^2]：任意到实现定义的限制。很抱歉，我们还没有弄清楚如何将无限量的数据压缩到计算机的有限内存量中。

## 表示内存中的 BigInts

通常，计算机将整数存储在其CPU的寄存器（现在通常为32或64位宽）或寄存器大小的内存块中。这将导致您可能熟悉的最小值和最大值。例如，32 位有符号整数可以保存 -2，147，483，648 到 2，147，483，647 之间的值。然而，BigInts的想法是不受这些限制的限制。

那么，如何用一百个、一千个或一百万个比特来存储一个BigInt呢？它不能放在寄存器中，所以我们在内存中分配一个对象。我们把它做得足够大，可以容纳所有BigInt的位，在一系列块中，我们称之为“数字” - 因为这在概念上非常类似于如何使用更多的数字来写出比“9”更大的数字，比如“10”;除非十进制系统使用从 0 到 9 的数字，否则我们的 BigInts 使用从 0 到 4294967295 的数字（即`2**32-1`).这是32位CPU寄存器\[^3]的值范围，没有符号位;我们单独存储标志位。在伪代码中，一个`BigInt`对象`3*32 = 96`位看起来像这样：

```js
{
  type: 'BigInt',
  sign: 0,
  num_digits: 3,
  digits: [0x12…, 0x34…, 0x56…],
}
```

\[^3]：在 64 位机器上，我们使用 64 位数字，即从 0 到 18446744073709551615（即`2n**64n-1n`).

## 回到学校，回到高德纳

使用保存在CPU寄存器中的整数非常容易：例如，将其中两个相乘，软件可以使用一个机器指令来告诉CPU“将这两个寄存器的内容相乘！”，CPU将做到这一点。对于 BigInt 算术，我们必须提出自己的解决方案。值得庆幸的是，这个特殊的任务是每个孩子在某些时候都学会如何解决的问题：还记得你在学校做了什么，当你不得不乘以345 \* 678并且不允许使用计算器时吗？

    345 * 678
    ---------
         30    //   5 * 6
    +   24     //  4  * 6
    +  18      // 3   * 6
    +     35   //   5 *  7
    +    28    //  4  *  7
    +   21     // 3   *  7
    +      40  //   5 *   8
    +     32   //  4  *   8
    +    24    // 3   *   8
    =========
       233910

这正是 V8 将 BigInts 相乘的方式：一次一个数字，将中间结果相加。该算法同样适用于`0`自`9`就像BigInt的更大数字一样。

唐纳德·高德纳（Donald Knuth）在他的经典著作第2卷中发表了由较小块组成的大数乘法和除法的具体实现*计算机编程的艺术*，一直追溯到1969年。V8的实现遵循本书，这表明这是计算机科学的一个相当永恒的东西。

## “更少的脱糖”==更多的糖果？

也许令人惊讶的是，我们不得不花费相当多的精力来获得看似简单的一元运算，比如`-x`，即可工作。迄今`-x`做完全一样`x * (-1)`，所以为了简化事情，V8在处理JavaScript时尽早精确地应用了这个替换，即在解析器中。这种方法被称为“脱糖”，因为它将表达式视为`-x`作为“句法糖”，用于`x * (-1)`.其他组件（解释器，编译器，整个运行时系统）甚至不需要知道什么是一元运算，因为它们只见过乘法，当然他们必须支持乘法。

然而，对于BigInts，这个实现突然变得无效，因为将BigInt乘以一个数字（比如`-1`） 必须抛出一个`TypeError`\[^4]解析器必须解吸`-x`自`x * (-1n)`如果`x`是一个 BigInt — 但解析器无法知道什么`x`将评估为。因此，我们不得不停止依赖这种早期的脱糖，而是在各地的Numbers和BigInts上添加对一元运算的适当支持。

\[^4]： 混合`BigInt`和`Number`通常不允许使用操作数类型。对于JavaScript来说，这有点不寻常，但是有[解释](/features/bigint#operators)对于此决定。

## 按位操作的乐趣

今天使用的大多数计算机系统都使用一种称为“二的补码”的巧妙技巧来存储有符号整数，该技巧具有很好的属性，即第一位表示符号，并且将1添加到位模式中始终使数字递增1，自动处理符号位。例如，对于 8 位整数：

*   `10000000`为 -128，表示的最低可表示数字，
*   `10000001`是 -127，
*   `11111111`是 -1，
*   `00000000`为 0，
*   `00000001`为 1，
*   `01111111`为 127，表示的最高数字。

这种编码是如此普遍，以至于许多程序员期望它并依赖它，而BigInt规范通过规定BigInts必须表现得好像他们使用二的补码表示来反映这一事实。如上所述，V8的BigInts没有！

因此，要根据规范执行按位运算，我们的 BigInts 必须假装在引擎盖下使用二进制补码。对于正值，它不会产生任何影响，但负数必须做额外的工作才能完成此操作。这有一些令人惊讶的效果，`a & b`如果`a`和`b`都是负的BigInts，实际上执行*四*步骤（如果它们都是正数，则只使用一个）：两个输入都转换为假二的补码格式，然后完成实际操作，然后将结果转换回我们的真实表示。你可能会问，为什么来回？因为所有非按位操作都以这种方式容易得多。

## 两种新型类型阵列

BigInt提案包括两种新的TypedArray口味：`BigInt64Array`和`BigUint64Array`.我们可以使用具有64位宽整数元素的TypedArrays，因为BigInts提供了一种自然的方式来读取和写入这些元素中的所有位，而如果尝试使用Numbers，某些位可能会丢失。这就是为什么新数组与现有的8/16/32位整数TypedArrays不太一样：访问它们的元素总是用BigInts完成的;尝试使用 Numbers 会引发异常。

```js
> const big_array = new BigInt64Array(1);
> big_array[0] = 123n;  // OK
> big_array[0]
123n
> big_array[0] = 456;
TypeError: Cannot convert 456 to a BigInt
> big_array[0] = BigInt(456);  // OK
```

就像使用这些类型的数组的JavaScript代码看起来和工作方式与传统的TypedArray代码有点不同一样，我们必须推广我们的TypedArray实现，以便对这两个新来者有不同的行为。

## 优化注意事项

目前，我们正在发布BigInts的基线实现。它在功能上是完整的，应该提供可靠的性能（比现有的用户空间库快一点），但它没有特别优化。原因是，根据我们优先考虑现实世界应用程序而不是人工基准的目标，我们首先想看看您将如何使用BigInts，以便我们可以精确地优化您关心的情况！

例如，如果我们看到相对较小的 BigInts（最多 64 位）是一个重要的用例，我们可以通过对它们使用特殊表示来使它们具有更高的内存效率：

```js
{
  type: 'BigInt-Int64',
  value: 0x12…,
}
```

还有一个细节有待观察，那就是我们是否应该对“int64”值范围、“uint64”范围或两者都这样做——记住，必须支持更少的快速路径意味着我们可以更快地交付它们，而且具有讽刺意味的是，每增加一条快速路径都会使其他一切变得有点慢，因为受影响的操作总是必须检查它是否适用。

另一个故事是在优化编译器中支持BigInts。对于在 64 位值上运行并在 64 位硬件上运行的计算量大的应用程序，将这些值保留在寄存器中比像我们目前那样将它们作为堆上的对象分配要有效得多。我们有计划如何实施这种支持，但这是另一种情况，我们首先想知道这是否真的是您，我们的用户最关心的;或者我们是否应该把时间花在别的事情上。

请向我们发送有关您使用 BigInts 的目的以及您遇到的任何问题的反馈！您可以通过我们的错误跟踪器与我们联系[crbug.com/v8/new](https://crbug.com/v8/new)，通过邮件发送至<v8-users@googlegroups.com>或[@v8js](https://twitter.com/v8js)在推特上。
