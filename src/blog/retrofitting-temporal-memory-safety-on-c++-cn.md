***

标题： “在C++上改造时间记忆安全性”
作者： 'Anton Bikineev， Michael Lippautz （[@mlippautz](https://twitter.com/mlippautz)）， 汉尼斯·佩耶 （[@PayerHannes](https://twitter.com/PayerHannes))'
化身：

*   安东-比基涅夫
*   迈克尔-利普茨
*   hannes-payer
    日期： 2022-06-14
    标签：
*   内部
*   记忆
*   安全
    描述： “通过堆扫描消除 Chrome 中的释放后使用漏洞。

***

：：：备注
**注意：**这篇文章最初发布在[谷歌安全博客](https://security.googleblog.com/2022/05/retrofitting-temporal-memory-safety-on-c.html).
:::

[Chrome 中的内存安全](https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html)是保护我们用户的一项持续努力。我们不断尝试不同的技术，以保持领先于恶意行为者。本着这种精神，这篇文章是关于我们使用堆扫描技术来提高C++内存安全性的旅程。

让我们从头开始。在应用程序的整个生存期内，其状态通常以内存表示。时态内存安全是指保证始终使用其结构，类型的最新信息访问内存的问题。很遗憾，C++不提供此类担保。虽然人们渴望使用比C++具有更强的内存安全保证的不同语言，但在可预见的未来，Chromium等大型代码库将使用C++。

```cpp
auto* foo = new Foo();
delete foo;
// The memory location pointed to by foo is not representing
// a Foo object anymore, as the object has been deleted (freed).
foo->Process();
```

在上面的例子中，`foo`在其内存返回到基础系统后使用。过期指针称为[悬空指针](https://en.wikipedia.org/wiki/Dangling_pointer)通过它进行的任何访问都会导致免使用后使用 （UAF） 访问。在最好的情况下，此类错误会导致明确定义的崩溃，在最坏的情况下，它们会导致恶意行为者可以利用的微妙破坏。

UAF通常很难在较大的代码库中发现，其中对象的所有权在各种组件之间转移。普遍的问题是如此普遍，以至于迄今为止，工业界和学术界都定期提出缓解策略。例子不胜枚举：C++各种智能指针用于在应用程序级别更好地定义和管理所有权;编译器中的静态分析用于首先避免编译有问题的代码;当静态分析失败时，动态工具，例如[C++消毒液](https://github.com/google/sanitizers)可以拦截访问并捕获特定执行上的问题。

可悲的是，Chrome对C++的使用在这里没有什么不同，而且大多数[高严重性安全漏洞是 UAF 问题](https://www.chromium.org/Home/chromium-security/memory-safety/).为了在问题进入生产阶段之前发现问题，使用了上述所有技术。除了常规测试之外，模糊测试器还确保动态工具始终有新的输入可供使用。Chrome甚至走得更远，并采用了一种名为C++垃圾回收器。[油锅](https://v8.dev/blog/oilpan-library)它偏离常规C++语义，但在使用时提供时间记忆安全。在这种偏差不合理的地方，一种新型的智能指针称为[奇迹大师](https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html)是最近引入的，用于在使用时确定性地崩溃对悬空指针的访问。Oilpan、MiraclePtr 和基于智能指针的解决方案需要大量采用应用程序代码。

在过去的十年中，另一种方法取得了一些成功：内存隔离。基本思想是将显式释放的内存放入隔离区，并且仅在达到特定安全条件时才可用。Microsoft 已在其浏览器中提供了此缓解措施的版本：[内存保护器](https://securityintelligence.com/understanding-ies-new-exploit-mitigations-the-memory-protector-and-the-isolated-heap/)在2014年的Internet Explorer及其继任者中[MemGC](https://securityintelligence.com/memgc-use-after-free-exploit-mitigation-in-edge-and-ie-on-windows-10/)在2015年的（前铬）边缘。在[Linux 内核](https://a13xp0p0v.github.io/2020/11/30/slab-quarantine.html)使用了一种概率方法，其中内存最终只是回收。近年来，这种方法在学术界引起了人们的关注。[马库斯纸](https://www.cst.cam.ac.uk/blog/tmj32/addressing-temporal-memory-safety).本文的其余部分总结了我们在 Chrome 中尝试隔离和堆扫描的过程。

（在这一点上，人们可能会问内存标记适合这张照片的位置 - 继续阅读！

## 隔离和堆扫描，基础知识

通过隔离和堆扫描确保时间安全背后的主要思想是避免重用内存，直到证明不再有（悬空）指针引用它。为了避免更改C++用户代码或其语义，内存分配器提供`new`和`delete`被拦截。

![Figure 1: quarantine basics](/\_img/retrofitting-temporal-memory-safety-on-c++/basics.svg)

调用时`delete`，则内存实际上被置于隔离区中，其中无法重复使用以进行后续操作`new`应用程序的调用。在某些时候，会触发堆扫描，扫描整个堆，就像垃圾回收器一样，以查找对隔离内存块的引用。没有来自常规应用程序内存的传入引用的块将传输回分配器，在那里它们可以在后续分配中重用。

有各种硬化选项会带来性能成本：

*   用特殊值（例如零）覆盖隔离的内存;
*   在扫描运行时停止所有应用程序线程或同时扫描堆;
*   拦截内存写入（例如通过页面保护）以捕获指针更新;
*   逐字扫描内存中可能的指针（保守处理）或为对象提供描述符（精确处理）;
*   在安全和不安全的分区中隔离应用程序内存，以选择退出某些对性能敏感或可以静态证明可以安全跳过的对象;
*   除了扫描堆内存外，还要扫描执行堆栈;

我们称之为这些算法的不同版本的集合*星扫描*\[stɑː skæn]，或*\*扫描*简称。

## 现实检查

我们将\*Scan应用于渲染器过程的非托管部分，并使用[车速表2](https://browserbench.org/Speedometer2.0/)以评估性能影响。

我们已经尝试了不同版本的\*Scan。但是，为了尽可能减少性能开销，我们评估了使用单独线程扫描堆并避免在 上急切地清除隔离内存的配置。`delete`而是在运行\*Scan时清除隔离的内存。我们选择使用`new`并且为了在第一个实现中简化，不要区分分配站点和类型。

![Figure 2: Scanning in separate thread](/\_img/retrofitting-temporal-memory-safety-on-c++/separate-thread.svg)

请注意，建议的 \*Scan 版本不完整。具体而言，恶意执行组件可能通过将悬空指针从未扫描的内存区域移动到已扫描的内存区域来利用扫描线程的争用条件。修复此争用条件需要跟踪写入已扫描内存块的操作，例如，通过使用内存保护机制来拦截这些访问，或者停止安全点中的所有应用程序线程完全改变对象图。无论哪种方式，解决此问题都会以性能为代价，并表现出有趣的性能和安全性权衡。请注意，这种攻击不是通用的，并不适用于所有UAF。诸如引言中描述的问题不会容易受到此类攻击，因为悬挂的指针不会被复制。

由于安全优势实际上取决于此类安全点的粒度，并且我们希望尝试使用最快的版本，因此我们完全禁用了安全点。

在 Speedometer2 上运行我们的基本版本会使总分降低 8%。无赖。。。

所有这些开销从何而来？不出所料，堆扫描是内存绑定的，并且非常昂贵，因为扫描线程必须遍历并检查整个用户内存的引用。

为了减少回归，我们实施了各种优化，以提高原始扫描速度。当然，扫描内存的最快方法是根本不扫描它，因此我们将堆划分为两类：可以包含指针的内存和我们可以静态证明不包含指针的内存，例如字符串。我们避免扫描不能包含任何指针的内存。请注意，此类内存仍然是隔离区的一部分，只是未进行扫描。

我们扩展了此机制，以涵盖用作其他分配器的支持内存的分配，例如，由 V8 管理的区域内存，用于优化 JavaScript 编译器。这些区域总是被立即丢弃（基于c.f.的内存管理），并且在V8中通过其他方式建立时间安全性。

最重要的是，我们应用了几个微优化来加速和消除计算：我们使用辅助器表进行指针过滤;依靠 SIMD 进行内存绑定的扫描循环;并尽量减少抓取和锁定前缀指令的数量。

我们还改进了初始调度算法，该算法在达到特定限制时仅启动堆扫描，方法是调整我们在扫描中花费的时间与实际执行应用程序代码相比（c.f. mutator利用率[垃圾收集文献](https://dl.acm.org/doi/10.1145/604131.604155)).

最后，该算法仍然受内存限制，扫描仍然是一个明显昂贵的过程。这些优化有助于将 Speedometer2 回归率从 8% 降低到 2%。

虽然我们改进了原始扫描时间，但内存位于隔离区中的事实增加了进程的整体工作集。为了进一步量化此开销，我们使用一组选定的[Chrome 的实际浏览基准测试](https://chromium.googlesource.com/catapult/)以测量内存消耗。\*在渲染器进程中扫描可减少约 12% 的内存消耗。正是这种工作集的增加导致更多的内存被分页，这在应用程序快速路径上是显而易见的。

## 硬件内存标记可救助

MTE（内存标记扩展）是 ARM v8.5A 体系结构上的新扩展，可帮助检测软件内存使用中的错误。这些错误可以是空间错误（例如，越界访问）或时间错误（释放后使用）。该扩展的工作原理如下。每 16 个字节的内存分配一个 4 位标记。指针还被分配了一个 4 位标记。分配器负责返回与分配的内存具有相同标记的指针。加载和存储指令验证指针和内存标记是否匹配。如果内存位置和指针的标记不匹配，则会引发硬件异常。

MTE 不提供针对免费后使用的确定性保护。由于标记位数是有限的，因此内存和指针的标记有可能由于溢出而匹配。使用 4 位时，只有 16 个重新分配就足以使标记匹配。恶意执行组件可以利用标记位溢出来获得释放后使用，只需等待悬空指针的标记（再次）匹配它所指向的内存即可。

\*扫描可用于修复此有问题的角落情况。在每个`delete`调用 MTE 机制递增的基础内存块的标记。大多数情况下，块将可用于重新分配，因为标记可以在4位范围内递增。过时的指针将引用旧标记，因此在取消引用时可靠地崩溃。标签溢出后，该对象将被放入隔离区并由 \*Scan 进行处理。一旦扫描确认不再有指向此内存块的悬空指针，它就会返回到分配器。这将扫描次数及其伴随成本降低了约 16 倍。

下图描述了这种机制。指向`foo`最初具有`0x0E`这允许它再次递增以进行分配`bar`.调用时`delete`为`bar`标签溢出，内存实际上被放入\*Scan的隔离区。

![Figure 3: MTE](/\_img/retrofitting-temporal-memory-safety-on-c++/mte.svg)

我们掌握了一些支持MTE的实际硬件，并在渲染器过程中重新进行了实验。结果是有希望的，因为Speedometer上的回归是在噪声范围内，我们在Chrome的真实世界浏览故事中仅将内存占用量减少了约1%。

这是实际的吗？[免费午餐](https://en.wikipedia.org/wiki/No_free_lunch_theorem)?事实证明，MTE附带了一些已经支付的费用。具体来说，默认情况下，Chrome的底层分配器PartageAlloc已经对所有启用了MTE的设备执行标签管理操作。此外，出于安全原因，内存确实应该立即清零。为了量化这些成本，我们在一个早期硬件原型上进行了实验，该原型在几种配置中支持MTE：

A. MTE 已禁用且内存未归零;
B. MTE 已禁用，但内存归零;
C. MTE 已启用，但未进行 \*扫描;
D. 启用了 MTE，并带有 \*扫描;

（我们也知道，同步和异步 MTE 也会影响确定性和性能。为了这个实验，我们继续使用异步模式。

![Figure 4: MTE regression](/\_img/retrofitting-temporal-memory-safety-on-c++/mte-regression.svg)

结果表明，MTE和内存归零带来了一些成本，在Speedometer2上约为2%。请注意，PartitionAlloc 和硬件都尚未针对这些方案进行优化。该实验还表明，在MTE之上添加\*Scan是没有可衡量成本的。

## 结论

C++允许编写高性能应用程序，但这需要付出代价，即安全性。硬件内存标记可以修复C++的一些安全隐患，同时仍允许高性能。我们期待将来更广泛地采用硬件内存标记，并建议在硬件内存标记之上使用\*Scan来修复C++的时间内存安全性。使用的MTE硬件和\*Scan的实现都是原型，我们希望仍有性能优化的空间。
