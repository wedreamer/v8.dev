***

标题： 'JavaScript 开发人员的代码缓存'
作者： '[莱谢克·斯维尔斯基](https://twitter.com/leszekswirski)，缓存粉碎器'
化身：

*   leszek-swirski
    日期： 2019-04-08 13：33：37
    更新时间：2020 年 6 月 16 日
    标签：
*   内部
    描述：“（字节）代码缓存通过缓存JavaScript解析+编译的结果来减少经常访问的网站的启动时间。
    推文：“1115264282675953664”

***

代码缓存（也称为*字节码缓存*） 是浏览器中的一项重要优化。它通过缓存解析+编译的结果来减少经常访问的网站的启动时间。最[流行](https://blog.mozilla.org/javascript/2017/12/12/javascript-startup-bytecode-cache/) [浏览器](https://bugs.webkit.org/show_bug.cgi?id=192782)实现某种形式的代码缓存，Chrome也不例外。事实上，我们已经[写](/blog/code-caching) [和](/blog/improved-code-caching) [谈到](https://www.youtube.com/watch?v=YqHOUy2rYZ8)关于过去Chrome和V8如何缓存编译代码。

在这篇博客文章中，我们为希望充分利用代码缓存来改善其网站启动的JS开发人员提供了一些建议。这个建议侧重于在Chrome/V8中实现缓存，但其中大部分也可能转移到其他浏览器的代码缓存实现中。

## 代码缓存回顾

虽然其他博客文章和演示文稿提供了有关我们的代码缓存实现的更多详细信息，但值得快速回顾一下事情是如何工作的。Chrome 为 V8 编译代码（经典脚本和模块脚本）提供了两个级别的缓存：由 V8 维护的低成本“尽力而为”的内存中缓存（`Isolate`缓存）和完全序列化的磁盘缓存。

这`Isolate`缓存操作在相同的V8 Isolate中编译的脚本（即相同的过程，大致是“在同一选项卡中导航时相同网站的页面”）。从某种意义上说，它是“尽力而为”的，因为它试图尽可能快和尽可能少地使用我们已经可用的数据，但代价是潜在的降低命中率和缺乏跨进程的缓存。

1.  当 V8 编译脚本时，编译的字节码存储在哈希表（在 V8 堆上）中，由脚本的源代码键控。
2.  当 Chrome 要求 V8 编译另一个脚本时，V8 首先会检查该脚本的源代码是否与此哈希表中的任何内容匹配。如果是，我们只需返回现有的字节码。

这个缓存是快速有效的免费，但我们观察到它在现实世界中获得了80%的命中率。

磁盘上的代码缓存由Chrome管理（特别是通过Blink管理），它填补了`Isolate`缓存不能：在进程之间以及多个 Chrome 会话之间共享代码缓存。它利用现有的 HTTP 资源缓存，该缓存管理从 Web 接收的缓存和过期数据。

1.  当首次请求 JS 文件时（即*冷运行*），Chrome会下载它并将其提供给V8进行编译。它还将文件存储在浏览器的磁盘缓存中。
2.  当第二次请求 JS 文件时（即*热运行*），Chrome 从浏览器缓存中获取文件，并再次将其提供给 V8 进行编译。但是，这一次，编译的代码将序列化，并作为元数据附加到缓存的脚本文件。
3.  第三次（即*热运行*），Chrome 从缓存中获取文件和文件的元数据，并将两者都交给 V8。V8 反序列化元数据，可以跳过编译。

综上所述：

![Code caching is split into cold, warm, and hot runs, using the in-memory cache on warm runs and the disk cache on hot runs.](/\_img/code-caching-for-devs/overview.svg)

根据此描述，我们可以提供最佳提示，以改善您的网站对代码缓存的使用。

## 提示 1：不执行任何操作 { #do-无 }

理想情况下，作为JS开发人员，您可以做的最好的事情就是“什么都不做”。这实际上意味着两件事：被动地什么都不做，主动什么都不做。

代码缓存归根结底是浏览器实现的细节;基于启发式的数据/空间权衡性能优化，其实现和启发式可以（并且确实！）定期更改。作为 V8 工程师，我们尽最大努力使这些启发式方法适用于不断发展的 Web 中的每个人，而过度优化当前的代码缓存实现细节可能会在几个版本发布后引起失望，当这些细节发生变化时。此外，其他 JavaScript 引擎可能对其代码缓存实现具有不同的启发式方法。因此，在许多方面，我们对缓存代码的最佳建议就像我们编写JS的建议一样：编写干净的惯用代码，我们将尽最大努力优化缓存方式。

除了被动地无所事事之外，你还应该尽力主动无所事事。任何形式的缓存本质上都依赖于不更改的内容，因此不执行任何操作是允许缓存数据保持缓存状态的最佳方法。有几种方法可以主动无所事事。

### 不要更改代码

这可能是显而易见的，但值得明确说明 - 每当您发布新代码时，该代码尚未缓存。每当浏览器对脚本URL发出HTTP请求时，它都可以包含上次获取该URL的日期，如果服务器知道文件没有更改，它可以发回304未修改响应，这将使我们的代码缓存保持热度。否则，200 OK 响应将更新缓存的资源，并清除代码缓存，将其恢复为冷运行。

![](/\_img/code-caching-for-devs/http-200-vs-304.jpg "Drake prefers HTTP 304 responses to HTTP 200 responses.")

总是立即推送最新的代码更改是很诱人的，特别是如果你想衡量某个更改的影响，但对于缓存，最好保留代码，或者至少尽可能少地更新它。考虑施加以下限制`≤ x`每周部署次数，其中`x`是可以调整为权衡缓存与过时性的滑块。

### 不要更改网址

代码缓存（当前）与脚本的 URL 相关联，因为这使它们易于查找，而无需读取实际的脚本内容。这意味着更改脚本的 URL（包括任何查询参数！）会在资源缓存中创建一个新的资源条目，并随之创建一个新的冷缓存条目。

当然，这也可以用于强制清除缓存，尽管这也是一个实现细节;我们可能会有一天决定将缓存与源文本而不是源URL相关联，并且此建议将不再有效。

### 不要更改执行行为

最近对代码缓存实现的优化之一是仅[在执行已编译的代码后对其进行序列化](/blog/improved-code-caching#increasing-the-amount-of-code-that-is-cached).这是为了尝试捕获懒惰编译的函数，这些函数仅在执行期间编译，而不是在初始编译期间编译。

当脚本的每次执行都执行相同的代码或至少相同的函数时，此优化效果最佳。例如，如果您有依赖于运行时决策的A / B测试，这可能是一个问题：

```js
if (Math.random() > 0.5) {
  A();
} else {
  B();
}
```

在这种情况下，仅`A()`或`B()`在热运行时编译和执行，并输入到代码缓存中，但任何一个都可以在后续运行中执行。相反，请尝试保持执行确定性，以将其保留在缓存路径上。

## 提示2：做一些事情{#do些东西}

当然，“无所事事”的建议，无论是被动的还是主动的，都不是很令人满意。因此，除了“什么都不做”之外，鉴于我们当前的启发式和实现，您还可以做一些事情。但请记住，启发式方法可以改变，此建议可能会改变，并且分析是无可替代的。

![](/\_img/code-caching-for-devs/with-great-power.jpg "Uncle Ben suggests that Peter Parker should be cautious when optimizing his web app’s cache behavior.")

### 使用它们从代码中分离出库 { #split }

代码缓存是按脚本粗略完成的，这意味着对脚本的任何部分的更改都会使整个脚本的缓存无效。如果您的发货代码在单个脚本中同时包含稳定部分和更改部分，例如库和业务逻辑，则对业务逻辑代码的更改会使库代码的缓存失效。

相反，您可以将稳定的库代码拆分为单独的脚本，并单独包含它。然后，库代码可以缓存一次，并在业务逻辑更改时保持缓存状态。

如果库在网站上的不同页面之间共享，则具有额外的好处：由于代码缓存附加到脚本，因此库的代码缓存也在页面之间共享。

### 使用它们将库合并到代码中 { #merge }

代码缓存是在每个脚本执行后完成的，这意味着脚本的代码缓存将恰好包含该脚本中在脚本完成执行时编译的那些函数。这对库代码有几个重要后果：

1.  代码缓存不会包含早期脚本中的函数。
2.  代码缓存不会包含由更高版本的脚本调用的延迟编译的函数。

特别是，如果库由完全延迟编译的函数组成，则即使以后使用这些函数，也不会缓存这些函数。

一种解决方案是将库及其用途合并到单个脚本中，以便代码缓存“看到”库的哪些部分被使用。不幸的是，这与上面的建议完全相反，因为没有银弹。一般来说，我们不建议将所有脚本JS合并到一个大的捆绑包中。将其拆分为多个较小的脚本往往更有利于整体上，因为除了代码缓存之外（例如，多个网络请求，流式编译，页面交互性等）。

### 利用 IIFE 启发式方法 { #iife }

只有在脚本完成执行时编译的函数才会计入代码缓存，因此有许多类型的函数尽管在稍后某个时间点执行，但不会缓存。事件处理程序（甚至`onload`），承诺链，未使用的库函数，以及任何其他懒散编译而不被调用的内容`</script>`被看到，所有保持懒惰并且不缓存。

强制缓存这些函数的一种方法是强制编译它们，强制编译的常见方法是使用 IIFE 启发式方法。IIFEs（立即调用的函数表达式）是一种在创建后立即调用函数的模式：

```js
(function foo() {
  // …
})();
```

由于IIFE是立即调用的，因此大多数JavaScript引擎会尝试检测它们并立即编译它们，以避免支付延迟编译后进行完整编译的成本。有各种启发式方法可以及早检测IFE（在必须解析函数之前），最常见的是`(`在`function`关键词。

由于这种启发式是早期应用的，因此即使该函数实际上没有立即被调用，它也会触发编译：

```js
const foo = function() {
  // Lazily skipped
};
const bar = (function() {
  // Eagerly compiled
});
```

这意味着可以通过将代码缓存中的函数括在括号中来强制它们。但是，如果错误地应用了提示，这可能会使启动时间受到影响，并且通常这在某种程度上是对启发式方法的滥用，因此我们的建议是除非有必要，否则请避免这样做。

### 将小文件组合在一起 { #group }

Chrome 的代码缓存最小大小，目前设置为[1 KiB 的源代码](https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/v8\_code_cache.cc?l=91\&rcl=2f81d000fdb5331121cba7ff81dfaaec25b520a5).这意味着根本不会缓存较小的脚本，因为我们认为开销大于收益。

如果您的网站有许多这样的小脚本，则开销计算可能不再以相同的方式适用。您可能需要考虑将它们合并在一起，以便它们超过最小代码大小，并从通常减少脚本开销中受益。

### 避免使用内联脚本

其源在 HTML 中内联的脚本标记没有与之关联的外部源文件，因此无法使用上述机制进行缓存。Chrome 确实会尝试通过将缓存附加到 HTML 文档的资源来缓存内联脚本，但这些缓存随后会依赖于*整个*HTML 文档不会更改，并且不会在页面之间共享。

因此，对于可以从代码缓存中受益的非平凡脚本，请避免将它们内联到HTML中，而更喜欢将它们作为外部文件包含在内。

### 使用服务工作线程缓存

服务工作线程是代码拦截对页面中资源的网络请求的一种机制。特别是，它们允许您构建某些资源的本地缓存，并在请求时从缓存中提供资源。这对于希望继续脱机工作的页面（如 PWA）特别有用。

使用服务工作线程的站点的典型示例在某个主脚本文件中注册服务工作线程：

```js
// main.mjs
navigator.serviceWorker.register('/sw.js');
```

服务工作线程添加用于安装（创建缓存）和提取（提供资源，可能来自缓存）的事件处理程序。

```js
// sw.js
self.addEventListener('install', (event) => {
  async function buildCache() {
    const cache = await caches.open(cacheName);
    return cache.addAll([
      '/main.css',
      '/main.mjs',
      '/offline.html',
    ]);
  }
  event.waitUntil(buildCache());
});

self.addEventListener('fetch', (event) => {
  async function cachedFetch(event) {
    const cache = await caches.open(cacheName);
    let response = await cache.match(event.request);
    if (response) return response;
    response = await fetch(event.request);
    cache.put(event.request, response.clone());
    return response;
  }
  event.respondWith(cachedFetch(event));
});
```

这些缓存可以包括缓存的 JS 资源。但是，我们对它们的启发式方法略有不同，因为我们可以做出不同的假设。由于服务工作线程缓存遵循配额托管的存储规则，因此它更有可能保留更长时间，并且缓存的好处会更大。 此外，当资源在加载之前预先缓存时，我们可以推断出资源的进一步重要性。

在服务工作线程安装事件期间将资源添加到服务工作线程缓存时，会发生最大的启发式差异。上面的示例演示了此类用法。在这种情况下，将资源放入服务工作线程缓存时，将立即创建代码缓存。此外，我们为这些脚本生成一个“完整”代码缓存 - 我们不再懒惰地编译函数，而是编译*万事*并将其放在缓存中。这具有快速且可预测的性能的优点，没有执行顺序依赖性，但代价是增加内存使用。

如果 JS 资源通过缓存 API 存储在服务工作线程安装事件之外，则代码缓存*不*立即生成。相反，如果服务工作线程使用缓存中的该响应进行响应，则将首先加载打开生成“正常”代码缓存。然后，此代码缓存将可用于在第二次加载时使用;加载速度比典型的代码缓存方案快一个。当在提取事件中“逐步”缓存资源时，或者如果缓存 API 是从主窗口而不是服务工作线程更新时，资源可能会存储在安装事件之外的缓存 API 中。

请注意，预缓存的“完整”代码缓存假定将运行脚本的页面将使用 UTF-8 编码。如果页面最终使用不同的编码，则代码缓存将被丢弃并替换为“正常”代码缓存。

此外，预缓存的“完整”代码缓存假定页面将作为经典 JS 脚本加载脚本。 如果页面最终将其作为ES模块加载，则代码缓存将被丢弃并替换为“正常”代码缓存。

## 描图

上述任何建议都不能保证加快您的 Web 应用的速度。遗憾的是，代码缓存信息当前未在 DevTools 中公开，因此找出哪些 Web 应用的脚本是代码缓存的最可靠方法是使用略低级别的脚本`chrome://tracing`.

`chrome://tracing`记录在一段时间内检测的 Chrome 跟踪，其中生成的跟踪可视化效果如下所示：

![The chrome://tracing UI with a recording of a warm cache run](/\_img/code-caching-for-devs/chrome-tracing-visualization.png)

跟踪会记录整个浏览器（包括其他选项卡、窗口和扩展程序）的行为，因此，在干净的用户配置文件中完成此操作、禁用扩展程序且未打开其他浏览器选项卡时，跟踪效果最佳：

```bash
# Start a new Chrome browser session with a clean user profile and extensions disabled
google-chrome --user-data-dir="$(mktemp -d)" --disable-extensions
```

收集跟踪时，必须选择要跟踪的类别。在大多数情况下，您只需选择“Web 开发人员”类别集，但您也可以手动选择类别。代码缓存的重要类别是`v8`.

![](/\_img/code-caching-for-devs/chrome-tracing-categories-1.png)

![](/\_img/code-caching-for-devs/chrome-tracing-categories-2.png)

记录跟踪后`v8`类别，查找`v8.compile`跟踪中的切片。（或者，您可以输入`v8.compile`在跟踪 UI 的搜索框中。它们列出了正在编译的文件，以及有关编译的一些元数据。

在脚本的冷运行时，没有关于代码缓存的信息 — 这意味着该脚本不参与生成或使用缓存数据。

![](/\_img/code-caching-for-devs/chrome-tracing-cold-run.png)

在温暖的跑步中，有两个`v8.compile`每个脚本的条目：一个用于实际编译（如上所述），一个（执行后）用于生成缓存。您可以识别后者，因为它具有`cacheProduceOptions`和`producedCacheSize`元数据字段。

![](/\_img/code-caching-for-devs/chrome-tracing-warm-run.png)

在热运行中，您会看到一个`v8.compile`用于使用缓存的条目，带有元数据字段`cacheConsumeOptions`和`consumedCacheSize`.所有大小均以字节表示。

![](/\_img/code-caching-for-devs/chrome-tracing-hot-run.png)

## 结论

对于大多数开发人员来说，代码缓存应该“正常工作”。当事情保持不变时，它像任何缓存一样效果最好，并且可以在版本之间更改的启发式方法上工作。尽管如此，代码缓存确实有可以使用的行为，以及可以避免的限制，并使用`chrome://tracing`可以帮助您调整和优化Web应用程序对缓存的使用。
