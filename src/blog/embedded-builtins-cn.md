***

标题： “嵌入式内置”
作者： '雅各布·格鲁伯 （[@schuay](https://twitter.com/schuay))'
化身：

*   “雅各布-格鲁伯”
    日期： 2018-08-14 13：33：37
    标签：
*   内部
    描述： 'V8 v6.9 将内置代码嵌入到二进制文件的 .text 部分中，使每个网站的 V8 堆大小中位数减少了 19%。
    推文：“1029382366693937162”

***

V8 内置函数（内置函数）会消耗 V8 的每个实例中的内存。每个 Chrome 浏览器标签的内置数量、平均大小和 V8 实例数量一直在显著增长。这篇博客文章介绍了我们在过去一年中如何将每个网站的 V8 堆大小中位数减少了 19%。

## 背景

V8 附带了一个广泛的 JavaScript （JS） 库[内置函数](/docs/builtin-functions).许多内置组件作为安装在 JS 内置对象上的函数直接向 JS 开发人员公开，例如`RegExp.prototype.exec`和`Array.prototype.sort`;其他内置实现各种内部功能。内置的机器代码由 V8 自己的编译器生成，并在初始化时加载到每个 V8 隔离的托管堆状态中。隔离器表示 V8 引擎的隔离实例，Chrome 中的每个浏览器标签页都至少包含一个隔离。每个隔离都有自己的托管堆，因此它有自己的所有内置副本。

早在2015年，内置组件大多在自托管JS，本机汇编或C++中实现。它们相当小，为每个隔离创建一个副本的问题就不那么严重了。

在过去几年中，这个领域发生了很大变化。

2016年，V8[开始](/blog/speeding-up-regular-expressions)试验在 中实现的内置[CodeStubAssembler](/blog/csa)（CSA）。事实证明，这既方便（独立于平台，可读），又可以生成高效的代码，因此CSA内置功能变得无处不在。由于各种原因，CSA 内置组件倾向于生成更大的代码，随着越来越多的内置组件移植到 CSA，V8 内置组件的大小大约增加了两倍。到 2017 年年中，他们的每隔离开销显著增加，我们开始考虑系统化解决方案。

![V8 snapshot size (including builtins) from 2015 until 2017](../_img/embedded-builtins/snapshot-size.png)

2017 年底，我们实施了[惰性内置（和字节码处理程序）反序列化](/blog/lazy-deserialization)作为第一步。我们的初步分析表明，大多数网站使用的不到所有内置的一半。使用惰性反序列化时，内置组件将按需加载，未使用的内置组件永远不会加载到隔离中。Chrome 64 中提供了惰性反序列化，有望节省内存。但是：内置内存开销在隔离的数量上仍然是线性的。

然后[幽灵](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html)被披露，Chrome最终打开了[站点隔离](https://security.googleblog.com/2018/07/mitigating-spectre-with-site-isolation.html)以减轻其影响。网站隔离将 Chrome 呈现器进程限制为来自单个源的文档。因此，通过站点隔离，许多浏览选项卡会创建更多的渲染器进程和更多的 V8 隔离。尽管管理每个隔离的开销一直很重要，但站点隔离使它变得更加重要。

## 嵌入式内置

我们这个项目的目标是完全消除每个隔离的内置开销。

它背后的想法很简单。从概念上讲，内置组件在隔离项之间是相同的，并且由于实现细节而仅绑定到隔离项。如果我们能够使内置组件真正独立于隔离，我们就可以在内存中保留一个副本，并在所有隔离器之间共享它们。如果我们能够使它们独立于流程，它们甚至可以跨流程共享。

在实践中，我们面临着几个挑战。生成的内置代码既不是隔离的，也不是独立于进程的，因为嵌入了用于隔离和特定于进程的数据的指针。V8 没有执行位于托管堆外部的生成代码的概念。内置组件必须跨进程共享，理想情况下是通过重用现有的操作系统机制来实现的。最后（原来是长尾），性能一定不会明显倒退。

以下各节详细介绍了我们的解决方案。

### 隔离和独立于过程的代码

内置由 V8 的编译器内部管道生成，该管道嵌入对堆常量（位于隔离的托管堆上）的引用，调用目标 （`Code`对象，也在托管堆上），并将特定于进程的地址（例如：C 运行时函数或指向隔离本身的指针，也称为“外部引用”）直接隔离到代码中。在 x64 程序集中，此类对象的加载可能如下所示：

    // Load an embedded address into register rbx.
    REX.W movq rbx,0x56526afd0f70

V8 有一个移动垃圾回收器，目标对象的位置可能会随时间而变化。如果在收集期间移动目标，GC 会更新生成的代码以指向新位置。

在 x64（和大多数其他体系结构）上，调用其他体系结构`Code`对象使用有效的调用指令，该指令通过与当前程序计数器的偏移量来指定调用目标（一个有趣的细节：V8保留其整个`CODE_SPACE`在启动时的托管堆上，以确保所有可能的 Code 对象都保持在彼此的可寻址偏移量内）。调用序列的相关部分如下所示：

    // Call instruction located at [pc + <offset>].
    call <offset>

![A pc-relative call](../_img/embedded-builtins/pc-relative-call.png)

代码对象本身位于托管堆上，并且是可移动的。当它们被移动时，GC 会更新所有相关呼叫站点的偏移量。

为了在进程之间共享内置组件，生成的代码必须是不可变的，并且与进程无关。上面的两个指令序列都不满足该要求：它们直接在代码中嵌入地址，并在运行时由GC进行修补。

为了解决这两个问题，我们通过一个专用的、所谓的根寄存器引入了一个间接寻址，该寄存器将指针指向当前隔离中的已知位置。

![Isolate layout](../_img/embedded-builtins/isolate-layout.png)

V8的`Isolate`class 包含根表，该表本身包含指向托管堆上根对象的指针。根寄存器永久保存根表的地址。

因此，加载根对象的新的，隔离的和独立于进程的方式变成了：

    // Load the constant address located at the given
    // offset from roots.
    REX.W movq rax,[kRootRegister + <offset>]

根堆常量可以直接从根列表加载，如上所述。其他堆常量通过全局内置常量池使用附加的间接寻址，该池本身存储在根列表中：

    // Load the builtins constant pool, then the
    // desired constant.
    REX.W movq rax,[kRootRegister + <offset>]
    REX.W movq rax,[rax + 0x1d7]

为`Code`目标，我们最初切换到一个更复杂的调用序列来加载目标`Code`来自全局内置常量池的对象，如上所述，将目标地址加载到寄存器中，最后执行间接调用。

通过这些更改，生成的代码变得孤立且独立于进程，我们可以开始在进程之间共享它。

## 跨流程共享

我们最初评估了两种选择。内置组件可以由以下人员共享：`mmap`-将数据 blob 文件放入内存中;或者，它们可以直接嵌入到二进制文件中。我们采用了后一种方法，因为它具有这样的优势，即我们可以自动重用标准操作系统机制来跨进程共享内存，并且更改不需要V8嵌入器（如Chrome）的额外逻辑。我们对这种方法充满信心，因为[Dart的AOT编译](https://www.youtube.com/watch?v=lqE4u8s8Iik)已经成功地嵌入了二进制嵌入生成的代码。

可执行二进制文件分为几个部分。例如，ELF 二进制文件包含`.data`（初始化数据），`.ro_data`（初始化的只读数据），以及`.bss`（未初始化的数据）部分，而本机可执行代码则放置在`.text`.我们的目标是将内置代码打包到`.text`部分以及本机代码。

![Sections of an executable binary file](../_img/embedded-builtins/binary-format.png)

这是通过引入一个新的构建步骤来完成的，该步骤使用V8的内部编译器管道为所有内置生成本机代码并将其内容输出到`embedded.cc`.然后，此文件将编译到最终的 V8 二进制文件中。

![The (simplified) V8 embedded build process](../_img/embedded-builtins/build-process.png)

这`embedded.cc`文件本身包含元数据和生成的内置机器代码作为一系列`.byte`指示C++编译器（在我们的例子中为 clang 或 gcc）将指定的字节序列直接放入输出对象文件（以及后来的可执行文件）中的指令。

    // Information about embedded builtins are included in
    // a metadata table.
    V8_EMBEDDED_TEXT_HEADER(v8_Default_embedded_blob_)
    __asm__(".byte 0x65,0x6d,0xcd,0x37,0xa8,0x1b,0x25,0x7e\n"
    [snip metadata]

    // Followed by the generated machine code.
    __asm__(V8_ASM_LABEL("Builtins_RecordWrite"));
    __asm__(".byte 0x55,0x48,0x89,0xe5,0x6a,0x18,0x48,0x83\n"
    [snip builtins code]

的内容`.text`节在运行时映射到只读可执行内存中，并且操作系统将在进程之间共享内存，只要它仅包含与位置无关的代码而没有可重定位符号。这正是我们想要的。

但是V8的`Code`对象不仅由指令流组成，而且还具有各种（有时依赖于隔离的）元数据。正常磨合`Code`对象将元数据和指令流打包到可变大小`Code`位于托管堆上的对象。

![On-heap Code object layout](../_img/embedded-builtins/code-on-heap.png)

正如我们所看到的，嵌入式内置的本机指令流位于托管堆之外，嵌入到`.text`部分。为了保留它们的元数据，每个嵌入式内置器还具有一个小的关联`Code`托管堆上的对象，称为*离堆蹦床*.元数据按标准存储在蹦床上`Code`对象，而内联指令流仅包含一个短序列，该序列加载嵌入式指令的地址并跳转到那里。

![Off-heap Code object layout](../_img/embedded-builtins/code-off-heap.png)

蹦床允许V8处理所有`Code`对象均匀。对于大多数目的，给定的`Code`对象是指托管堆上的标准代码或嵌入式内置代码。

### 优化性能

在前面几节中描述的解决方案中，嵌入式内置组件基本上是功能完备的，但基准测试表明它们的速度明显变慢。例如，我们最初的解决方案倒退了[车速表 2.0](/blog/speedometer-2)总体超过5%。

我们开始寻找优化机会，并确定了经济放缓的主要来源。由于频繁的间接寻址来访问隔离和依赖于进程的对象，生成的代码速度较慢。根常量是从根列表加载的（1 个间接寻址），从全局内置常量池（2 个间接寻址）加载其他堆常量，并且还必须从堆对象（3 个间接寻址）中解压缩外部引用。最严重的违规者是我们新的调用序列，它必须加载蹦床代码对象，调用它，然后跳转到目标地址。最后，托管堆和二进制嵌入式代码之间的调用似乎本身就更慢，可能是由于长跳距离干扰了 CPU 的分支预测。

因此，我们的工作集中在1.减少间接联系，以及 2.改进内置调用序列。为了解决前者，我们更改了隔离对象布局，将大多数对象加载转换为单个根相对负载。全局内置常量池仍然存在，但仅包含不常访问的对象。

![Optimized Isolate layout](../_img/embedded-builtins/isolate-layout-optimized.png)

呼叫序列在两个方面得到了显着改进。内置到内置的调用被转换为单个 pc 相对调用指令。对于运行时生成的 JIT 代码，这是不可能的，因为 pc 相对偏移量可能超过最大 32 位值。在那里，我们将堆外蹦床内联到所有呼叫站点，将呼叫顺序从6个减少到只有2个指令。

通过这些优化，我们能够将速度计 2.0 上的回归限制在大约 0.5%。

## 结果

我们评估了嵌入式内置对x64的影响，而不是最受欢迎的前10000个网站，并与懒惰和急切的反序列化（如上所述）进行了比较。

![V8 heap size reduction vs. eager and lazy deserialization](../_img/embedded-builtins/results.png)

以前，Chrome 会附带一个内存映射快照，我们会在每个隔离器上反序列化该快照，而现在，快照被嵌入的内置组件所取代，这些内置内容仍采用内存映射，但不需要反序列化。内置成本曾经是`c*(1 + n)`哪里`n`是隔离株的数量，并且`c`所有内置的内存成本，而现在它只是`c * 1`（在实践中，对于堆外蹦床，还保留了少量的每隔离架空）。

与预先反序列化相比，我们将 V8 堆大小的中位数减少了 19%。每个站点的 Chrome 渲染器进程大小中位数减少了 4%。在绝对数字中，第 50 个百分位保存 1.9 MB，第 30 个百分位保存 3.4 MB，第 10 个百分位每个站点节省 6.5 MB。

一旦字节码处理程序也嵌入二进制，预计会节省大量额外的内存。

嵌入式内置组件将在Chrome 69的x64上推出，移动平台将在Chrome 70中推出。对ia32的支持预计将于2018年底发布。

：：：备注
**注意：**所有图表都是使用维亚切斯拉夫·叶戈罗夫的真棒生成的[摇晃的图表](https://mrale.ph/blog/2012/11/25/shaky-diagramming.html)工具。
:::
