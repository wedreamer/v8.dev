***

标题： “WebAssembly 中最多 4GB 的内存”
作者：“Andreas Haas，Jakob Kummerow和Alon Zakai”
化身：

*   “安德烈亚斯-哈斯”
*   'jakob-kummerow'
*   'alon-zakai'
    日期： 2020-05-14
    标签：
*   WebAssembly
*   JavaScript
*   工具
    推文：“1260944314441633793”

***

## 介绍

由于最近在Chrome和Emscripten中的工作，您现在可以在WebAssembly应用程序中使用高达4GB的内存。这比之前的2GB限制要高。有一个限制似乎很奇怪 - 毕竟，不需要任何工作就可以允许人们使用512MB或1GB的内存！- 但事实证明，在浏览器和工具链中，从2GB跳到4GB的过程中发生了一些特殊的事情，我们将在这篇文章中介绍。

## 32 位

在我们进入更多细节之前，先了解一些背景知识：新的4GB限制是32位指针可能的最大内存量，这是WebAssembly目前支持的，在LLVM和其他地方被称为“wasm32”。有一个“wasm64”（[“记忆64”](https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md)在 wasm 规范中），其中指针可以是 64 位，我们将能够利用超过 1600 万 TB 的内存（！），但在此之前，4GB 是我们可能希望能够访问的最多内存。

似乎我们应该总是能够访问4GB，因为这是32位指针所允许的。那么，为什么我们被限制在一半，只有2GB呢？在浏览器和工具链方面都有多种原因。让我们从浏览器开始。

## 铬/V8 工作

原则上，V8 中的更改听起来很简单：只要确保为 WebAssembly 函数生成的所有代码以及所有内存管理代码都使用无符号的 32 位整数作为内存索引和长度，我们就应该完成了。但是，在实践中，还有更多！由于WebAssembly内存可以作为ArrayBuffer导出到JavaScript，我们还必须更改JavaScript ArrayBuffers，TypedArrays以及所有使用ArrayBuffers和TypedArrays的Web API的实现，如Web Audio，WebGPU和WebUSB。

我们必须解决的第一个问题是V8使用了[斯米斯](https://v8.dev/blog/pointer-compression#value-tagging-in-v8)（即 31 位有符号整数）对于 TypedArray 索引和长度，因此最大大小实际上是 2<sup>30</sup>-1，或约1GB。此外，事实证明，将所有内容切换到32位整数是不够的，因为4GB内存的长度实际上不适合32位整数。举个例子：在十进制中，有100个数字有两位数字（0到99），但“100”本身就是一个三位数字。类似地，4GB可以用32位地址寻址，但4GB本身就是一个33位数字。我们本可以满足于一个稍微下限，但是由于我们无论如何都必须触及所有TypedArray代码，因此我们希望在使用它时为将来更大的限制做好准备。因此，我们将所有处理 TypedArray 索引或长度的代码更改为使用 64 位宽的整数类型，或者需要与 JavaScript 接口的 JavaScript Numbers。作为额外的好处，这意味着支持wasm64更大的内存现在应该相对简单！

第二个挑战是处理 JavaScript 对 Array 元素的特殊大小写，与常规命名属性相比，这反映在我们的对象实现中。（这是一个与JavaScript规范有关的相当技术性的问题，所以如果你不遵循所有细节，请不要担心。请考虑以下示例：

```js
console.log(array[5_000_000_000]);
```

如果`array`是一个普通的 JavaScript 对象或数组，则`array[5_000_000_000]`将作为基于字符串的属性查找进行处理。运行时将查找字符串命名的属性“5000000000”。如果找不到这样的属性，它将沿着原型链向上移动并寻找该属性，或者最终返回。`undefined`在链的末端。但是，如果`array`本身或其原型链上的对象是TypedArray，则运行时必须在索引5，000，000，000处查找索引元素，否则立即返回`undefined`如果此索引超出范围。

换句话说，TypedArrays的规则与普通数组有很大不同，这种差异主要体现在大型索引上。因此，只要我们只允许较小的TypedArrays，我们的实现就可以相对简单;特别是，仅查看一次属性键就足以决定是否应采用“索引”或“命名”查找路径。为了允许更大的TypedArrays，我们现在必须在沿着原型链向上走时反复进行这种区分，这需要仔细的缓存，以避免通过重复的工作和开销来减慢现有的JavaScript代码。

## 工具链工作

在工具链方面，我们也必须做工作，其中大部分是在JavaScript支持代码上，而不是WebAssembly中的编译代码。主要问题是Emscripten总是以这种形式编写内存访问：

```js
HEAP32[(ptr + offset) >> 2]
```

从地址读取 32 位（4 字节）作为有符号整数`ptr + offset`.这是如何工作的`HEAP32`是一个 Int32 数组，这意味着数组中的每个索引都有 4 个字节。所以我们需要将字节地址（`ptr + offset`） 按 4 获取索引，这是什么`>> 2`确实如此。

问题是`>>`是一个*签署*操作！如果地址位于 2GB 标记或更高，它将溢出输入为负数：

```js
// Just below 2GB is ok, this prints 536870911
console.log((2 * 1024 * 1024 * 1024 - 4) >> 2);
// 2GB overflows and we get -536870912 :(
console.log((2 * 1024 * 1024 * 1024) >> 2);
```

解决方案是做一个*符号*转变`>>>`:

```js
// This gives us 536870912, as we want!
console.log((2 * 1024 * 1024 * 1024) >>> 2);
```

Emscripten 在编译时知道您是否可以使用 2GB 或更多内存（取决于您使用的标志;有关详细信息，请参阅后面的内存）。如果你的标志使2GB+地址成为可能，那么编译器将自动重写所有内存访问以使用`>>>`而不是`>>`，其中不仅包括`HEAP32`等访问，如上面的例子，但也包括这样的操作`.subarray()`和`.copyWithin()`.换句话说，编译器将切换到使用无符号指针而不是有符号指针。

这种转换稍微增加了代码大小 - 每个班次中多一个字符 - 这就是为什么如果您不使用2GB +地址，我们不会这样做的原因。虽然差异通常小于1%，但这只是不必要的，并且很容易避免 - 并且许多小的优化加起来！

JavaScript 支持代码中可能会出现其他罕见的问题。虽然正常的内存访问如前所述自动处理，但手动将签名指针与未签名指针进行比较之类的操作（在地址 2GB 及以上）将返回 false。为了找到这样的问题，我们审核了Emscripten的JavaScript，并在特殊模式下运行测试套件，其中所有内容都放置在2GB或更高的地址。（请注意，如果您编写自己的JavaScript支持代码，那么除了正常的内存访问之外，如果您使用指针手动操作，则可能还需要修复一些问题。

## 尝试一下

为了测试这一点，[获取最新的 Emscripten 版本](https://emscripten.org/docs/getting_started/downloads.html)，或至少版本 1.39.15。然后使用标志进行构建，例如

    emcc -s ALLOW_MEMORY_GROWTH -s MAXIMUM_MEMORY=4GB

这些使内存增长成为可能，并允许程序一直分配到4GB的内存。请注意，默认情况下，您最多只能分配2GB - 您必须明确选择使用2-4GB（这允许我们通过发射来发出更紧凑的代码）`>>`而不是`>>>`如上所述）。

请务必在 Chrome M83（目前处于 Beta 阶段）或更高版本上进行测试。如果您发现任何问题，请提交问题！

## 结论

支持高达4GB的内存是使Web与本机平台一样强大的另一步，允许32位程序能够像平常一样使用尽可能多的内存。就其本身而言，这并不能启用一类全新的应用程序，但它确实支持更高端的体验，例如游戏中的非常大的关卡或在图形编辑器中操作大型内容。

如前所述，还计划支持64位内存，这将允许访问甚至超过4GB。但是，wasm64 的缺点与本机平台上的 64 位相同，即指针占用的内存是其两倍。这就是为什么在 wasm32 中支持 4GB 如此重要的原因：我们可以访问比以前多两倍的内存，同时代码大小保持与 wasm 一直以来一样紧凑！

与往常一样，在多个浏览器上测试您的代码，并记住2-4GB是很多内存！如果你需要那么多，你应该使用它，但不要不必要地这样做，因为许多用户的机器上没有足够的可用内存。我们建议您从尽可能小的初始内存开始，并在必要时进行增长。如果您允许增长，请优雅地处理`malloc()`失败。
