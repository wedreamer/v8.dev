***

标题： “改进 V8 正则表达式”
作者：“Patrick Thier和Ana Peško，关于正则表达式观点的正则表达者”
化身：

*   “帕特里克-他们的”
*   'ana-pesko'
    日期： 2019-10-04 15：24：16
    标签：
*   内部
*   正则表达式
    描述： “在这篇博客文章中，我们描述了我们如何利用解释正则表达式的好处并减轻缺点。
    推文：“1180131710568030208”

***

在其默认配置中，V8 在第一次执行时将正则表达式编译为本机代码。作为我们工作的一部分[无JIT V8](/blog/jitless)，我们引入了正则表达式的解释器。解释正则表达式具有使用较少内存的优点，但它会降低性能。在这篇博客文章中，我们将介绍如何利用解释正则表达式的好处，同时减轻缺点。

## 正则表达式的分层策略

我们希望将“两全其美”用于正则表达式。为此，我们首先将所有正则表达式编译为字节码并解释它们。通过这种方式，我们节省了大量的内存，并且总体而言（以及新的，更快的解释器）性能损失是可以接受的。如果再次使用具有相同模式的正则表达式，我们认为它是“热的”，因此我们重新编译为本机代码。从这一点开始，我们尽可能快地继续执行。

在 V8 中，正则表达式代码有许多不同的路径，具体取决于调用的方法，它是全局正则表达式还是非全局正则表达式，以及我们是采用快速路径还是慢速路径。话虽如此，我们希望分层决策尽可能集中。我们向 V8 的 RegExp 对象添加了一个刻度字段，该字段在运行时初始化为某个值。此值表示在升级到编译器之前解释正则表达式的次数。每次解释正则表达式时，我们都会将刻度字段递减 1。在内置的[CodeStubAssembler](/blog/csa)它为所有正则表达式调用，我们在每次执行时检查价格变动标志。一旦价格变动达到 0，我们知道我们需要将正则表达式重新编译为本机代码，然后我们跳转到运行时来执行此操作。

我们已经提到正则表达式可以有不同的执行路径。对于用函数作为参数的全局替换的情况，本机代码和字节码的实现不同。本机代码期望数组预先存储所有匹配项，并且字节码一次匹配一个。因此，我们决定始终热切地升级到此用例的本机代码。

## 加快 RegExp 解释器的速度

### 消除运行时开销

执行正则表达式时，内置[CodeStubAssembler](/blog/csa)被调用。这个内置的以前检查过JSRegExp对象的代码字段是否包含可以直接执行的JITted本机代码，否则称为运行时方法来编译（或在无JIT模式下解释）RegExp。在无 JIT 模式下，正则表达式的每次执行都经过 V8 运行时，这是非常昂贵的，因为我们需要在 JavaScript 和执行堆栈上的C++代码之间转换。

从 V8 v7.8 开始，每当 RegExp 编译器生成字节码来解释正则表达式时，除了生成的字节码之外，RegExp 解释器的蹦床现在还存储在 JSRegExp 对象的代码字段中。这样，解释器现在可以直接从内置中调用，而无需绕道通过运行时。

### 新的调度方法

RegExp解释器以前使用的简单`switch`基于调度方法。此方法的主要缺点是 CPU 很难预测要执行的下一个字节码，从而导致许多分支误读，从而减慢了执行速度。

我们在 V8 v7.8 中将调度方法更改为线程代码。此方法允许 CPU 的分支预测器根据当前执行的字节码预测下一个字节码，从而减少误定。更详细地说，我们使用调度表，存储每个字节码ID和实现字节码的处理程序的地址之间的映射。V8的解释器[点火](/docs/ignition)也使用此方法。但是，Ignition和RegExp解释器之间的一大区别在于Ignition的字节码处理程序是写在[CodeStubAssembler](/blog/csa)，而整个 RegExp 解释器是用 C++ 编写的[计算`goto`s](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html)（clang也支持GNU扩展），它比CSA更容易阅读和维护。对于不支持计算 gotos 的编译器，我们回退到旧的`switch`基于调度方法。

### 字节码窥视孔优化

在我们讨论字节码窥视孔优化之前，让我们看一个激励的例子。

```js
const re = /[^_]*/;
const str = 'a0b*c_ef';
re.exec(str);
// → matches 'a0b*c'
```

对于此简单模式，RegExp 编译器创建 3 个字节码，为每个字符执行这些字节码。在高层次上，这些是：

1.  加载当前字符。
2.  检查字符是否等于`'_'`.
3.  如果不是，则将当前位置提前到主题字符串中，然后`goto 1`.

对于我们的主题字符串，我们解释17个字节码，直到找到一个不匹配的字符。窥视孔优化的想法是，我们将字节码序列替换为新的优化字节码，该字节码结合了多个字节码的功能。在我们的示例中，我们甚至可以处理由`goto`显式地在新字节码中，因此单个字节码处理所有匹配的字符，从而节省了 16 次调度。

尽管该示例是编造的，但此处描述的字节码序列在实际网站中经常发生。我们分析了[真正的网站](/blog/real-world-performance)并为我们遇到的最常见的字节码序列创建新的优化字节码。

## 结果

![Figure 1: Memory savings for different tier-up values](/\_img/regexp-tier-up/results-memory.svg)

图1显示了Facebook，Reddit，Twitter和Tumblr浏览故事的不同分层策略对内存的影响。默认值是 JITted 代码的大小，然后我们有最终使用的正则表达式代码的大小（如果我们不分层，则使用字节码大小，如果我们这样做，则使用本机代码大小）来初始化为 1、10 和 100。最后，如果我们解释所有正则表达式，我们将拥有正则表达式代码的大小。我们已经使用这些结果和其他基准来决定使用初始化为 1 的刻度来打开向上层，即我们解释正则表达式一次，然后向上分层。

通过这种分层策略，我们在真实站点上将 V8 的堆代码大小减少了 4% 到 7%，将 V8 的有效大小减少了 1% 到 2%。

![Figure 2: RegExp performance comparison](/\_img/regexp-tier-up/results-speed.svg)

图 2 显示了本博客文章\[^strict-bounds] 中描述的对 RexBench 基准测试套件上所有改进的 RegExp 解释器性能的影响。作为参考，还显示了 JIT 编译的正则表达式的性能（本机）。

\[^strict-bounds]：此处显示的结果还包括对[V8 v7.8 发行说明](/blog/v8-release-78#faster-regexp-match-failures).

新译员的速度是旧译员的2×，平均速度约为1.45×对于大多数基准测试，我们甚至非常接近JITted RegExp的性能，Regex DNA是唯一的例外。在此基准测试中，解释的正则表达式比 JITted RegExp 慢得多的原因是由于使用了长的主题字符串（约 300，000 个字符）。尽管我们将调度开销降至最低，但开销对超过 1，000 个字符的字符串的总和，从而导致执行速度变慢。由于解释器在长字符串上的速度要慢得多，因此我们添加了一个启发式方法，可以热切地为这些字符串分层。

## 结论

从 V8 v7.9 （Chrome 79） 开始，我们对正则表达式进行分层，而不是急切地编译它们。因此，以前只在无JIT的V8中使用的解释器现在无处不在。因此，我们节省了内存。我们加快了口译员的速度，使这成为可能。但这还不是故事的结局——未来可以期待更多的改进。

我们想借此机会感谢V8团队的每个人在我们实习期间给予的支持。这是一次很棒的体验！
