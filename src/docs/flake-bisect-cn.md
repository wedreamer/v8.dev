***

## 标题： “片状一分为二”&#xA;描述： “本文档解释了如何将片状测试一分为二。

片状测试在机器人上的单独步骤中报告（[示例构建](https://ci.chromium.org/ui/p/v8/builders/ci/V8%20Linux64%20TSAN/38630/overview)).

每个测试日志都提供了一个预填充的命令行，用于触发自动片状分割，例如：

    Trigger flake bisect on command line:
    bb add v8/try.triggered/v8_flako -p 'to_revision="deadbeef"' -p 'test_name="MyTest"' ...

在首次触发片状一分为二之前，用户必须使用 google.com 帐户登录：

```bash
bb auth-login
```

然后执行提供的命令，该命令返回运行片状二分切 （[例](https://ci.chromium.org/ui/p/v8/builders/try.triggered/v8\_flako/b8836020260675019825/overview)).

如果你运气好的话，分等份会把你指向一个嫌疑人。如果没有，您可能想进一步阅读...

## 详细说明

有关技术详细信息，另请参阅实现[跟踪器错误](https://crbug.com/711249).片状二分法具有与[芬迪特](https://sites.google.com/chromium.org/cat/findit)，但使用不同的实现。

### 它是如何工作的？

一对切作业有 3 个阶段：校准、向后和向内平分。在校准期间，重复测试，使总超时（或重复次数）加倍，直到在一次运行中检测到足够的薄片。然后，向后对等分将 git 范围加倍，直到找到没有薄片的修订版。最后，我们将好修订版和最古老的坏修订版的范围一分为二。请注意，二分法不会生成新的构建产品，它纯粹基于之前在 V8 的持续基础架构上创建的构建。

### 当...

*   在校准过程中无法达到置信度。这对于百万分之一的薄片或片状行为是典型的，只有在其他测试并行运行时才可见（例如，内存消耗测试）。
*   罪魁祸首太老了。Bisection 在完成一定数量的步骤后，或者如果较旧的内部版本在隔离服务器上不再可用，则 Bisection 将进行救援。
*   整体一分为二的作业超时。在这种情况下，可以使用较旧的已知错误修订版重新启动它。

## 用于自定义片状二分的属性

*   `extra_args`：传递给 V8 的额外参数`run-tests.py`脚本。
*   重复次数：初始测试重复次数（传递到`run-tests.py`的`--random-seed-stress-count`选项;在以下情况下未使用`total_timeout_sec`使用）。
*   `timeout_sec`：超时参数传递给`run-tests.py`.
*   `to_revision`：已知不良的修订版。这是对等分将开始的地方。
*   `total_timeout_sec`：一个完整的二分步进的初始总超时。在校准期间，如果需要，该时间会加倍几次。设置为 0 可禁用并使用`repetitions`而是属性。
*   `variant`：传递到的测试变体的名称`run-tests.py`.

## 您不需要更改的属性

*   `bisect_buildername`：生成对等剖构建体的构建者的主名称。
*   `bisect_mastername`：生成对等剖构建的构建者的名称。
*   `build_config`：构建配置已传递到 V8 的`run-tests.py`脚本（其中参数名称为`--mode`例：`Release`或`Debug`).
*   `isolated_name`：独立文件的名称（例如`bot_default`,`mjsunit`).
*   `swarming_dimensions`：对测试应在其上运行的机器人类型进行分类的维度。作为字符串列表传递，每个字符串的格式`name:value`.
*   `test_name`：完全限定的测试名称已传递给 run-tests.py。例如：`mjsunit/foobar`.

## 提示和技巧

### 将悬挂测试一分为二（例如死锁）

如果失败的运行超时，而传递运行得非常快，则调整timeout_sec参数很有用，这样在等待挂起的运行超时时时，对等操作就不会延迟。例如，如果通常在<1秒内达到通过，则将超时设置为小值，例如5秒。

### 对嫌疑人更有信心

在某些运行中，置信度非常低。例如，如果在一次运行中看到四片薄片，则满足校准要求。在分切期间，每次使用一个或多个薄片的跑步都被视为不良。在这种情况下，重新启动对二分作业设置（to_revision罪魁祸首）并使用比原始作业更多的重复次数或总超时次数，并确认再次得出相同的结论，可能会很有用。

### 解决超时问题

如果整体超时选项导致构建挂起，最好估计一个合适的重复次数并设置`total_timeout_sec`自`0`.

### 取决于随机种子的测试行为

在极少数情况下，代码路径仅由特定的随机种子触发。在这种情况下，使用以下命令修复它可能是有益的`extra_args`，例如`"extra_args": ["--random-seed=123"]`.否则，压力运行器在整个过程中使用不同的随机种子。但请注意，特定的随机种子可能会在一个修订版中重现问题，但在另一个修订版中则不会。
